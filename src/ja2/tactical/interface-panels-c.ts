// DEFINES FOR VARIOUS PANELS
const CLOCK_X = 554;
const CLOCK_Y = 459;
const SM_ITEMDESC_START_X = 214;
const SM_ITEMDESC_START_Y = 1 + INV_INTERFACE_START_Y;
const SM_ITEMDESC_HEIGHT = 128;
const SM_ITEMDESC_WIDTH = 358;

// SINGLE MERC SCREEN

const SM_SELMERC_AP_X = 70;
const SM_SELMERC_AP_Y = 393;
const SM_SELMERC_AP_HEIGHT = 12;
const SM_SELMERC_AP_WIDTH = 11;

const SM_SELMERC_BREATH_X = 75;
const SM_SELMERC_BREATH_Y = 387;
const SM_SELMERC_BREATH_WIDTH = 3;
const SM_SELMERC_BREATH_HEIGHT = 42;

const SM_SELMERC_HEALTH_X = 69;
const SM_SELMERC_HEALTH_Y = 387;
const SM_SELMERC_HEALTH_WIDTH = 3;
const SM_SELMERC_HEALTH_HEIGHT = 42;

const SM_SELMERC_MORALE_X = 81;
const SM_SELMERC_MORALE_Y = 387;
const SM_SELMERC_MORALE_WIDTH = 3;
const SM_SELMERC_MORALE_HEIGHT = 42;

const SM_SELMERCNAME_X = 7;
const SM_SELMERCNAME_Y = 395;

const SM_SELMERCNAME_WIDTH = 53;
const SM_SELMERCNAME_HEIGHT = 9;

const SM_SELMERC_FACE_X = 13;
const SM_SELMERC_FACE_Y = 346;
const SM_SELMERC_FACE_HEIGHT = 42;
const SM_SELMERC_FACE_WIDTH = 48;

const SM_SELMERC_PLATE_X = 4;
const SM_SELMERC_PLATE_Y = 342;
const SM_SELMERC_PLATE_HEIGHT = 65;
const SM_SELMERC_PLATE_WIDTH = 83;

const SM_BODYINV_X = 244;
const SM_BODYINV_Y = 346;

const STATS_TITLE_FONT_COLOR = 6;
const STATS_TEXT_FONT_COLOR = 5;

const SM_TALKB_X = 155;
const SM_TALKB_Y = 448;
const SM_MUTEB_X = 91;
const SM_MUTEB_Y = 448;
const SM_STANCEUPB_X = 187;
const SM_STANCEUPB_Y = 380;
const SM_UPDOWNB_X = 91;
const SM_UPDOWNB_Y = 413;
const SM_CLIMBB_X = 187;
const SM_CLIMBB_Y = 348;
const SM_STANCEDOWNB_X = 187;
const SM_STANCEDOWNB_Y = 448;
const SM_HANDCURSORB_X = 123;
const SM_HANDCURSORB_Y = 413;
const SM_PREVMERCB_X = 9;
const SM_PREVMERCB_Y = 410;
const SM_NEXTMERCB_X = 51;
const SM_NEXTMERCB_Y = 410;
const SM_OPTIONSB_X = 9;
const SM_OPTIONSB_Y = 445;
const SM_BURSTMODEB_X = 155;
const SM_BURSTMODEB_Y = 413;
const SM_LOOKB_X = 123;
const SM_LOOKB_Y = 448;
const SM_STEALTHMODE_X = 187;
const SM_STEALTHMODE_Y = 413;
const SM_DONE_X = 543;
const SM_DONE_Y = 344;
const SM_MAPSCREEN_X = 589;
const SM_MAPSCREEN_Y = 344;

const SM_POSITIONB_X = 106 + INTERFACE_START_X;
const SM_POSITIONB_Y = 34 + INV_INTERFACE_START_Y;
const SM_POSITIONB_WIDTH = 19;
const SM_POSITIONB_HEIGHT = 24;

const SM_PERCENT_WIDTH = 20;
const SM_PERCENT_HEIGHT = 10;
const SM_ARMOR_X = 347;
const SM_ARMOR_Y = 419;
const SM_ARMOR_LABEL_X = 363;
const SM_ARMOR_LABEL_Y = 409;
const SM_ARMOR_PERCENT_X = 368;
const SM_ARMOR_PERCENT_Y = 419;

const SM_WEIGHT_LABEL_X = 430;
const SM_WEIGHT_LABEL_Y = 447;
const SM_WEIGHT_PERCENT_X = 449;
const SM_WEIGHT_PERCENT_Y = 446;
const SM_WEIGHT_X = 428;
const SM_WEIGHT_Y = 446;

const SM_CAMMO_LABEL_X = 430;
const SM_CAMMO_LABEL_Y = 462;
const SM_CAMMO_PERCENT_X = 449;
const SM_CAMMO_PERCENT_Y = 461;
const SM_CAMMO_X = 428;
const SM_CAMMO_Y = 461;

const SM_STATS_WIDTH = 30;
const SM_STATS_HEIGHT = 8;
const SM_AGI_X = 99;
const SM_AGI_Y = 347;
const SM_DEX_X = 99;
const SM_DEX_Y = 357;
const SM_STR_X = 99;
const SM_STR_Y = 367;
const SM_CHAR_X = 99;
const SM_CHAR_Y = 377;
const SM_WIS_X = 99;
const SM_WIS_Y = 387;
const SM_EXPLVL_X = 148;
const SM_EXPLVL_Y = 347;
const SM_MRKM_X = 148;
const SM_MRKM_Y = 357;
const SM_EXPL_X = 148;
const SM_EXPL_Y = 367;
const SM_MECH_X = 148;
const SM_MECH_Y = 377;
const SM_MED_X = 148;
const SM_MED_Y = 387;

const MONEY_X = 460;
const MONEY_Y = 445;
const MONEY_WIDTH = 30;
const MONEY_HEIGHT = 22;

const TM_FACE_WIDTH = 48;
const TM_FACE_HEIGHT = 43;

const TM_APPANEL_HEIGHT = 56;
const TM_APPANEL_WIDTH = 16;

const TM_ENDTURN_X = 507;
const TM_ENDTURN_Y = (9 + INTERFACE_START_Y);
const TM_ROSTERMODE_X = 507;
const TM_ROSTERMODE_Y = (45 + INTERFACE_START_Y);
const TM_DISK_X = 507;
const TM_DISK_Y = (81 + INTERFACE_START_Y);

const TM_NAME_WIDTH = 60;
const TM_NAME_HEIGHT = 9;
const TM_LIFEBAR_WIDTH = 3;
const TM_LIFEBAR_HEIGHT = 42;
const TM_FACEHIGHTL_WIDTH = 84;
const TM_FACEHIGHTL_HEIGHT = 114;
const TM_AP_HEIGHT = 10;
const TM_AP_WIDTH = 15;

const TM_INV_WIDTH = 58;
const TM_INV_HEIGHT = 23;
const TM_INV_HAND1STARTX = 8;
const TM_INV_HAND1STARTY = (67 + INTERFACE_START_Y);
const TM_INV_HAND2STARTX = 8;
const TM_INV_HAND2STARTY = (93 + INTERFACE_START_Y);
const TM_INV_HAND_SEP = 83;
const TM_INV_HAND_SEPY = 24;

const TM_BARS_REGION_HEIGHT = 47;
const TM_BARS_REGION_WIDTH = 26;

const INDICATOR_BOX_WIDTH = 12;
const INDICATOR_BOX_HEIGHT = 10;

const enum Enum218 {
  STANCEUP_IMAGES = 0,
  UPDOWN_IMAGES,
  CLIMB_IMAGES,
  STANCEDOWN_IMAGES,
  HANDCURSOR_IMAGES,
  PREVMERC_IMAGES,
  NEXTMERC_IMAGES,
  OPTIONS_IMAGES,
  // BURSTMODE_IMAGES,
  LOOK_IMAGES,
  TALK_IMAGES,
  MUTE_IMAGES,
  STANCE_IMAGES,
  DONE_IMAGES,
  MAPSCREEN_IMAGES,
  NUM_SM_BUTTON_IMAGES,
}

const enum Enum219 {
  ENDTURN_IMAGES = 0,
  ROSTERMODE_IMAGES,
  DISK_IMAGES,
  NUM_TEAM_BUTTON_IMAGES,
}

let iSMPanelImages: INT32[] /* [NUM_SM_BUTTON_IMAGES] */;
let iBurstButtonImages: INT32[] /* [NUM_WEAPON_MODES] */;
let iTEAMPanelImages: INT32[] /* [NUM_TEAM_BUTTON_IMAGES] */;

let giSMStealthImages: INT32 = -1;
let giSMStealthButton: INT32 = -1;

let gfSwitchPanel: BOOLEAN = FALSE;
let gbNewPanel: UINT8 = SM_PANEL;
let gubNewPanelParam: UINT8 = 0;

let gfUIStanceDifferent: BOOLEAN = FALSE;
let gfAllDisabled: BOOLEAN = FALSE;

let gfSMDisableForItems: BOOLEAN = FALSE;

let gfDisableTacticalPanelButtons: BOOLEAN = FALSE;

let gfAddingMoneyToMercFromPlayersAccount: BOOLEAN = FALSE;

let gfCheckForMouseOverItem: BOOLEAN = FALSE;
let guiMouseOverItemTime: UINT32 = 0;
let gbCheckForMouseOverItemPos: INT8 = 0;
let gubSelectSMPanelToMerc: UINT8 = NOBODY;
let gfReEvaluateDisabledINVPanelButtons: BOOLEAN = FALSE;

let guiBrownBackgroundForTeamPanel: UINT32;
let guiGoldBackgroundForTeamPanel: UINT32;

let gubHandPos: UINT8;
let gusOldItemIndex: UINT16;
let gusNewItemIndex: UINT16;
let gfDeductPoints: BOOLEAN;

// ARRAY FOR INV PANEL INTERFACE ITEM POSITIONS
let gSMInvPocketXY: INV_REGION_DESC[] /* [] */ = [
  [ 344, 347 ], // HELMETPOS
  [ 344, 376 ], // VESTPOS
  [ 344, 436 ], // LEGPOS,
  [ 226, 347 ], // HEAD1POS
  [ 226, 371 ], // HEAD2POS
  [ 226, 424 ], // HANDPOS,
  [ 226, 448 ], // SECONDHANDPOS
  [ 468, 346 ], // BIGPOCK1
  [ 468, 370 ], // BIGPOCK2
  [ 468, 394 ], // BIGPOCK3
  [ 468, 418 ], // BIGPOCK4
  [ 396, 346 ], // SMALLPOCK1
  [ 396, 370 ], // SMALLPOCK2
  [ 396, 394 ], // SMALLPOCK3
  [ 396, 418 ], // SMALLPOCK4
  [ 432, 346 ], // SMALLPOCK5
  [ 432, 370 ], // SMALLPOCK6
  [ 432, 394 ], // SMALLPOCK7
  [ 432, 418 ], // SMALLPOCK8
];

let gSMCamoXY: INV_REGION_DESC = [
  SM_BODYINV_X, SM_BODYINV_Y // X, Y Location of cammo region
];

let sTEAMAPPanelXY: INT16[] /* [] */ = [
  69, (6 + INTERFACE_START_Y),
  151, (6 + INTERFACE_START_Y),
  234, (6 + INTERFACE_START_Y),
  317, (6 + INTERFACE_START_Y),
  401, (6 + INTERFACE_START_Y),
  484, (6 + INTERFACE_START_Y),
];

let sTEAMFacesXY: INT16[] /* [] */ = [
  13, (366),
  97, (366),
  180, (366),
  263, (366),
  346, (366),
  429, (366),
];

let sTEAMNamesXY: INT16[] /* [] */ = [
  7, (415),
  90, (415),
  173, (415),
  256, (415),
  339, (415),
  422, (415),
];

let sTEAMFaceHighlXY: INT16[] /* [] */ = [
  4, (2 + INTERFACE_START_Y),
  87, (2 + INTERFACE_START_Y),
  170, (2 + INTERFACE_START_Y),
  253, (2 + INTERFACE_START_Y),
  336, (2 + INTERFACE_START_Y),
  419, (2 + INTERFACE_START_Y),
];

let sTEAMLifeXY: INT16[] /* [] */ = [
  69, (365 + TM_LIFEBAR_HEIGHT),
  152, (365 + TM_LIFEBAR_HEIGHT),
  235, (365 + TM_LIFEBAR_HEIGHT),
  318, (365 + TM_LIFEBAR_HEIGHT),
  401, (365 + TM_LIFEBAR_HEIGHT),
  484, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMBreathXY: INT16[] /* [] */ = [
  75, (365 + TM_LIFEBAR_HEIGHT),
  158, (365 + TM_LIFEBAR_HEIGHT),
  241, (365 + TM_LIFEBAR_HEIGHT),
  324, (365 + TM_LIFEBAR_HEIGHT),
  407, (365 + TM_LIFEBAR_HEIGHT),
  490, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMMoraleXY: INT16[] /* [] */ = [
  81, (365 + TM_LIFEBAR_HEIGHT),
  164, (365 + TM_LIFEBAR_HEIGHT),
  247, (365 + TM_LIFEBAR_HEIGHT),
  330, (365 + TM_LIFEBAR_HEIGHT),
  413, (365 + TM_LIFEBAR_HEIGHT),
  496, (365 + TM_LIFEBAR_HEIGHT),
];

let sTEAMApXY: INT16[] /* [] */ = [
  70, (413),
  153, (413),
  235, (413),
  319, (413),
  402, (413),
  485, (413),
];

let sTEAMBarsXY: INT16[] /* [] */ = [
  61, (363),
  145, (363),
  228, (363),
  311, (363),
  394, (363),
  477, (362),
];

let sTEAMHandInvXY: INT16[] /* [] */ = [
  TM_INV_HAND1STARTX + (0 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (1 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (2 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (3 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (4 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
  TM_INV_HAND1STARTX + (5 * TM_INV_HAND_SEP), TM_INV_HAND1STARTY,
];

let iSMPanelButtons: INT32[] /* [NUM_SM_BUTTONS] */;
let iTEAMPanelButtons: INT32[] /* [NUM_TEAM_BUTTONS] */;

// Video Surface for Single Merc Panel
let guiSMPanel: UINT32;
let guiSMObjects: UINT32;
let guiSMObjects2: UINT32;
let guiSecItemHiddenVO: UINT32;

let guiTEAMPanel: UINT32;
let guiTEAMObjects: UINT32;

// Globals for various mouse regions
let gSM_SELMERCPanelRegion: MOUSE_REGION;
let gSM_SELMERCBarsRegion: MOUSE_REGION;
let gSM_SELMERCMoneyRegion: MOUSE_REGION;
let gSM_SELMERCEnemyIndicatorRegion: MOUSE_REGION;
let gTEAM_PanelRegion: MOUSE_REGION;
let gTEAM_FaceRegions: MOUSE_REGION[] /* [6] */;
let gTEAM_BarsRegions: MOUSE_REGION[] /* [6] */;
let gTEAM_LeftBarsRegions: MOUSE_REGION[] /* [6] */;
let gTEAM_FirstHandInv: MOUSE_REGION[] /* [6] */;
let gTEAM_SecondHandInv: MOUSE_REGION[] /* [6] */;
let gTEAM_EnemyIndicator: MOUSE_REGION[] /* [6] */;

let gfTEAM_HandInvDispText: BOOLEAN[][] /* [6][NUM_INV_SLOTS] */;
let gfSM_HandInvDispText: BOOLEAN[] /* [NUM_INV_SLOTS] */;

// Globals - for one - the current merc here
let gusSMCurrentMerc: UINT16 = 0;
let gpSMCurrentMerc: Pointer<SOLDIERTYPE> = NULL;
let gbSMCurStanceObj: INT8;

let gbStanceButPos: INT8[][][] /* [2][3][3] */ = [
  // NON-STEALTH
  [
    [
      [ 16, 14, 15 ],
      [ 10, 8, 9 ],
      [ 22, 20, 21 ],
    ],
  ],

  // STEALTH MODE
  [
    [
      [ 13, 11, 12 ],
      [ 7, 5, 6 ],
      [ 19, 17, 18 ],
    ],
  ],
];

// Wraps up check for AP-s get from a different soldier for in a vehicle...
function GetUIApsToDisplay(pSoldier: Pointer<SOLDIERTYPE>): INT8 {
  let pVehicle: Pointer<SOLDIERTYPE>;

  if (pSoldier.value.uiStatusFlags & SOLDIER_DRIVER) {
    pVehicle = GetSoldierStructureForVehicle(pSoldier.value.iVehicleId);

    if (pVehicle != NULL) {
      return pVehicle.value.bActionPoints;
    } else {
      return 0;
    }
  } else {
    return pSoldier.value.bActionPoints;
  }
}

function CheckForDisabledForGiveItem(): void {
  let sDist: INT16;
  let sDistVisible: INT16;
  let sDestGridNo: INT16;
  let bDestLevel: INT8;
  let cnt: INT32;
  let pSoldier: Pointer<SOLDIERTYPE>;
  let ubSrcSoldier: UINT8;

  Assert(gpSMCurrentMerc != NULL);

  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
    gfSMDisableForItems = !CanMercInteractWithSelectedShopkeeper(gpSMCurrentMerc);
    return;
  }

  // Default to true
  gfSMDisableForItems = TRUE;

  // ATE: Is the current merc unconscious.....
  if (gpSMCurrentMerc.value.bLife < OKLIFE && gpItemPointer != NULL) {
    // Go through each merc and see if there is one closeby....
    cnt = gTacticalStatus.Team[gbPlayerNum].bFirstID;
    for (pSoldier = MercPtrs[cnt]; cnt <= gTacticalStatus.Team[gbPlayerNum].bLastID; cnt++, pSoldier++) {
      if (pSoldier.value.bActive && pSoldier.value.bLife >= OKLIFE && !(pSoldier.value.uiStatusFlags & SOLDIER_VEHICLE) && !AM_A_ROBOT(pSoldier) && pSoldier.value.bInSector && IsMercOnCurrentSquad(pSoldier)) {
        sDist = PythSpacesAway(gpSMCurrentMerc.value.sGridNo, pSoldier.value.sGridNo);

        sDistVisible = DistanceVisible(pSoldier, DIRECTION_IRRELEVANT, DIRECTION_IRRELEVANT, gpSMCurrentMerc.value.sGridNo, gpSMCurrentMerc.value.bLevel);

        // Check LOS....
        if (SoldierTo3DLocationLineOfSightTest(pSoldier, gpSMCurrentMerc.value.sGridNo, gpSMCurrentMerc.value.bLevel, 3, sDistVisible, TRUE)) {
          if (sDist <= PASSING_ITEM_DISTANCE_NOTOKLIFE) {
            gfSMDisableForItems = FALSE;
            break; // found one, no need to keep looking
          }
        }
      }
    }
  } else {
    ubSrcSoldier = gusSelectedSoldier;

    if (gpItemPointer != NULL) {
      ubSrcSoldier = gpItemPointerSoldier.value.ubID;
    }

    // OK buddy, check our currently selected merc and disable/enable if not close enough...
    if (ubSrcSoldier != NOBODY) {
      if (gusSMCurrentMerc != ubSrcSoldier) {
        sDestGridNo = MercPtrs[gusSMCurrentMerc].value.sGridNo;
        bDestLevel = MercPtrs[gusSMCurrentMerc].value.bLevel;

        // Get distance....
        sDist = PythSpacesAway(MercPtrs[ubSrcSoldier].value.sGridNo, sDestGridNo);

        // is he close enough to see that gridno if he turns his head?
        sDistVisible = DistanceVisible(MercPtrs[ubSrcSoldier], DIRECTION_IRRELEVANT, DIRECTION_IRRELEVANT, sDestGridNo, bDestLevel);

        // Check LOS....
        if (SoldierTo3DLocationLineOfSightTest(MercPtrs[ubSrcSoldier], sDestGridNo, bDestLevel, 3, sDistVisible, TRUE)) {
          // UNCONSCIOUS GUYS ONLY 1 tile AWAY
          if (MercPtrs[gusSMCurrentMerc].value.bLife < CONSCIOUSNESS) {
            if (sDist <= PASSING_ITEM_DISTANCE_NOTOKLIFE) {
              gfSMDisableForItems = FALSE;
            }
          } else if (sDist <= PASSING_ITEM_DISTANCE_OKLIFE) {
            gfSMDisableForItems = FALSE;
          }
        }
      } else {
        gfSMDisableForItems = FALSE;
      }
    } else {
      gfSMDisableForItems = FALSE;
    }
  }
}

function SetSMPanelCurrentMerc(ubNewID: UINT8): void {
  gubSelectSMPanelToMerc = NOBODY;

  gusSMCurrentMerc = ubNewID;

  gpSMCurrentMerc = MercPtrs[ubNewID];

  // Set to current guy's interface level
  // if ( gsInterfaceLevel != gpSMCurrentMerc->bUIInterfaceLevel )
  //{
  //	SetRenderFlags(RENDER_FLAG_FULL);
  //	ErasePath(FALSE);
  //	gsInterfaceLevel = gpSMCurrentMerc->bUIInterfaceLevel;
  //}

  // Disable all faces
  SetAllAutoFacesInactive();

  // Turn off compat ammo....
  if (gpItemPointer == NULL) {
    HandleCompatibleAmmoUI(gpSMCurrentMerc, HANDPOS, FALSE);
    gfCheckForMouseOverItem = FALSE;
  } else {
    // Turn it all false first....
    InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, FALSE);
    InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, TRUE);
  }

  // Remove item desc panel if one up....
  if (gfInItemDescBox) {
    DeleteItemDescriptionBox();
  }

  if (gfInItemPickupMenu) {
    gfSMDisableForItems = TRUE;
  } else {
    if ((gpItemPointer != NULL || guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE || gpSMCurrentMerc.value.bLife < OKLIFE)) {
      CheckForDisabledForGiveItem();
    } else {
      gfSMDisableForItems = FALSE;
    }
  }

  if (gpItemPointer != NULL) {
    ReevaluateItemHatches(gpSMCurrentMerc, FALSE);
  }

  DisableInvRegions(gfSMDisableForItems);

  fInterfacePanelDirty = DIRTYLEVEL2;

  gfUIStanceDifferent = TRUE;

  UpdateSMPanel();
}

function UpdateForContOverPortrait(pSoldier: Pointer<SOLDIERTYPE>, fOn: BOOLEAN): void {
  let cnt: INT32;

  if (gsCurInterfacePanel == SM_PANEL) {
    if (gpSMCurrentMerc != NULL) {
      // Check if mouse is in region and if so, adjust...
      if (IsMouseInRegion(addressof(gSM_SELMERCPanelRegion))) {
        HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, fOn);
      }
    }
  } else {
    for (cnt = 0; cnt < 6; cnt++) {
      if (gTeamPanel[cnt].ubID == pSoldier.value.ubID) {
        if (IsMouseInRegion(addressof(gTEAM_FaceRegions[cnt]))) {
          HandleMouseOverSoldierFaceForContMove(pSoldier, fOn);
        }
      }
    }
  }
}

function UpdateSMPanel(): void {
  let fNearHeigherLevel: BOOLEAN;
  let fNearLowerLevel: BOOLEAN;
  let bDirection: INT8;
  let ubStanceState: UINT8;

  if (gpSMCurrentMerc.value.sGridNo == NOWHERE) {
    return;
  }

  // Stance
  ubStanceState = gpSMCurrentMerc.value.ubDesiredHeight;

  if (ubStanceState == NO_DESIRED_HEIGHT) {
    ubStanceState = gAnimControl[gpSMCurrentMerc.value.usAnimState].ubEndHeight;
  }

  switch (ubStanceState) {
    case ANIM_STAND:

      gbSMCurStanceObj = 0;
      DisableButton(iSMPanelButtons[STANCEUP_BUTTON]);
      EnableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);

      // Disable if we cannot do this!
      if (!IsValidStance(gpSMCurrentMerc, ANIM_CROUCH)) {
        DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
      }
      break;

    case ANIM_PRONE:
      gbSMCurStanceObj = 2;
      DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
      EnableButton(iSMPanelButtons[STANCEUP_BUTTON]);
      break;

    case ANIM_CROUCH:
      gbSMCurStanceObj = 1;
      EnableButton(iSMPanelButtons[STANCEUP_BUTTON]);
      EnableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);

      // Disable if we cannot do this!
      if (!IsValidStance(gpSMCurrentMerc, ANIM_PRONE)) {
        DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
      }
      break;
  }

  // Stance button done wether we're disabled or not...
  if (gfUIStanceDifferent) {
    // Remove old
    if (giSMStealthButton != -1) {
      RemoveButton(giSMStealthButton);
    }
    if (giSMStealthImages != -1) {
      UnloadButtonImage(giSMStealthImages);
    }

    // Make new
    giSMStealthImages = UseLoadedButtonImage(iSMPanelImages[STANCE_IMAGES], gbStanceButPos[gpSMCurrentMerc.value.bStealthMode][gbSMCurStanceObj][0], gbStanceButPos[gpSMCurrentMerc.value.bStealthMode][gbSMCurStanceObj][1], -1, gbStanceButPos[gpSMCurrentMerc.value.bStealthMode][gbSMCurStanceObj][2], -1);

    giSMStealthButton = QuickCreateButton(giSMStealthImages, SM_STEALTHMODE_X, SM_STEALTHMODE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnStealthModeCallback);

    SetButtonFastHelpText(giSMStealthButton, TacticalStr[TOGGLE_STEALTH_MODE_POPUPTEXT]);

    gfUIStanceDifferent = FALSE;

    if (gfAllDisabled) {
      if (giSMStealthButton != -1) {
        DisableButton(giSMStealthButton);
      }
    }
  }

  if (gfAllDisabled) {
    return;
  }

  CheckForReEvaluateDisabledINVPanelButtons();

  // Check for any newly added items we need.....
  if (gpSMCurrentMerc.value.fCheckForNewlyAddedItems) {
    // Startup any newly added items....
    CheckForAnyNewlyAddedItems(gpSMCurrentMerc);

    gpSMCurrentMerc.value.fCheckForNewlyAddedItems = FALSE;
  }

  // Set Disable /Enable UI based on buddy's stats
  if (ButtonList[iSMPanelButtons[BURSTMODE_BUTTON]].value.ImageNum != iBurstButtonImages[gpSMCurrentMerc.value.bWeaponMode]) {
    ButtonList[iSMPanelButtons[BURSTMODE_BUTTON]].value.ImageNum = iBurstButtonImages[gpSMCurrentMerc.value.bWeaponMode];
    ButtonList[iSMPanelButtons[BURSTMODE_BUTTON]].value.uiFlags |= BUTTON_DIRTY;
  }

  /*
  if ( gpSMCurrentMerc->bDoBurst )
  {
          if ( !ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->ubToggleButtonActivated )
          {
                  ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->uiFlags |= BUTTON_CLICKED_ON;
          }
  }
  else
  {
          if ( !ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->ubToggleButtonActivated )
          {
                  ButtonList[ iSMPanelButtons[ BURSTMODE_BUTTON ] ]->uiFlags &= ( ~BUTTON_CLICKED_ON );
          }
  }
  */

  // Toggle MUTE button...
  if (gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_MUTE) {
    if (!ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  DisableButton(iSMPanelButtons[CLIMB_BUTTON]);

  GetMercClimbDirection(gpSMCurrentMerc.value.ubID, addressof(fNearLowerLevel), addressof(fNearHeigherLevel));

  if (fNearLowerLevel || fNearHeigherLevel) {
    if (fNearLowerLevel) {
      if (EnoughPoints(gpSMCurrentMerc, GetAPsToClimbRoof(gpSMCurrentMerc, TRUE), 0, FALSE)) {
        EnableButton(iSMPanelButtons[CLIMB_BUTTON]);
      }
    }

    if (fNearHeigherLevel) {
      if (EnoughPoints(gpSMCurrentMerc, GetAPsToClimbRoof(gpSMCurrentMerc, FALSE), 0, FALSE)) {
        EnableButton(iSMPanelButtons[CLIMB_BUTTON]);
      }
    }
  }

  if (FindFenceJumpDirection(gpSMCurrentMerc, gpSMCurrentMerc.value.sGridNo, gpSMCurrentMerc.value.bDirection, addressof(bDirection))) {
    EnableButton(iSMPanelButtons[CLIMB_BUTTON]);
  }

  if ((gTacticalStatus.ubCurrentTeam != gbPlayerNum) || (gTacticalStatus.uiFlags & REALTIME) || !(gTacticalStatus.uiFlags & INCOMBAT)) {
    DisableButton(iSMPanelButtons[SM_DONE_BUTTON]);
  } else if (!gfAllDisabled) {
    EnableButton(iSMPanelButtons[SM_DONE_BUTTON]);
  }

  //	if ( gpSMCurrentMerc->bUIInterfaceLevel > 0 )
  if (gsInterfaceLevel > 0) {
    if (!ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.uiFlags |= (BUTTON_CLICKED_ON);
    }
  } else {
    if (!ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == HANDCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == TALKCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[TALK_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[TALK_BUTTON]].value.uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[TALK_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[TALK_BUTTON]].value.uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  if (gCurrentUIMode == LOOKCURSOR_MODE) {
    if (!ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.uiFlags |= BUTTON_CLICKED_ON;
    }
  } else {
    if (!ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.ubToggleButtonActivated) {
      ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.uiFlags &= (~BUTTON_CLICKED_ON);
    }
  }

  // If not selected ( or dead ), disable/gray some buttons
  if (gusSelectedSoldier != gpSMCurrentMerc.value.ubID || (gpSMCurrentMerc.value.bLife < OKLIFE) || (gTacticalStatus.ubCurrentTeam != gbPlayerNum) || gfSMDisableForItems) {
    DisableButton(iSMPanelButtons[CLIMB_BUTTON]);
    DisableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
    DisableButton(iSMPanelButtons[STANCEUP_BUTTON]);
    DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
    DisableButton(iSMPanelButtons[LOOK_BUTTON]);
    DisableButton(iSMPanelButtons[UPDOWN_BUTTON]);
    DisableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);
    if (giSMStealthButton != -1) {
      DisableButton(giSMStealthButton);
    }
  } else {
    // Enable some buttons!
    if (IsGunBurstCapable(gpSMCurrentMerc, HANDPOS, FALSE) || FindAttachment(addressof(gpSMCurrentMerc.value.inv[HANDPOS]), UNDER_GLAUNCHER) != ITEM_NOT_FOUND) {
      EnableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
    } else {
      DisableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
    }
    EnableButton(iSMPanelButtons[LOOK_BUTTON]);
    EnableButton(iSMPanelButtons[UPDOWN_BUTTON]);
    EnableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);

    if (giSMStealthButton != -1) {
      EnableButton(giSMStealthButton);
    }
  }

  // CJC Dec 4 2002: or if item pickup menu is up
  if ((gTacticalStatus.uiFlags & ENGAGED_IN_CONV) || gfInItemPickupMenu) {
    DisableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
  }
}

function ReevaluateItemHatches(pSoldier: Pointer<SOLDIERTYPE>, fAllValid: BOOLEAN): void {
  let cnt: INT32;

  // if there's an item in the cursor and we're not supposed to just make them all valid
  if ((gpItemPointer != NULL) && !fAllValid) {
    // check all inventory positions and mark the ones where cursor item won't fit as invalid
    for (cnt = 0; cnt < NUM_INV_SLOTS; cnt++) {
      gbInvalidPlacementSlot[cnt] = !CanItemFitInPosition(pSoldier, gpItemPointer, cnt, FALSE);

      // !!! ATTACHING/MERGING ITEMS IN MAP SCREEN IS NOT SUPPORTED !!!
      // CJC: seems to be supported now...
      // if( guiCurrentScreen != MAP_SCREEN )
      {
        // Check attachments, override to valid placement if valid merge...
        if (ValidAttachment(gpItemPointer.value.usItem, pSoldier.value.inv[cnt].usItem)) {
          gbInvalidPlacementSlot[cnt] = FALSE;
        }

        if (ValidMerge(gpItemPointer.value.usItem, pSoldier.value.inv[cnt].usItem)) {
          gbInvalidPlacementSlot[cnt] = FALSE;
        }
      }
    }
  } else {
    // mark all inventory positions as valid
    for (cnt = 0; cnt < NUM_INV_SLOTS; cnt++) {
      gbInvalidPlacementSlot[cnt] = FALSE;
    }
  }

  fInterfacePanelDirty = DIRTYLEVEL2;
}

function EnableSMPanelButtons(fEnable: BOOLEAN, fFromItemPickup: BOOLEAN): void {
  if (fFromItemPickup) {
    // If we have the item pointer up...
    // CJC Dec 4 2002: or if item pickup menu is up
    // if ( gpItemPointer != NULL )
    if (gpItemPointer != NULL || gfInItemPickupMenu) {
      DisableTacticalTeamPanelButtons(TRUE);
    } else {
      DisableTacticalTeamPanelButtons(FALSE);
    }

    fInterfacePanelDirty = DIRTYLEVEL2;
  }

  if (gsCurInterfacePanel == SM_PANEL) {
    if (fFromItemPickup) {
      // If we have the item pointer up...
      if (gpItemPointer != NULL) {
        ReevaluateItemHatches(gpSMCurrentMerc, fEnable);

        // Turn it all false first....
        InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, FALSE);
        InternalHandleCompatibleAmmoUI(gpSMCurrentMerc, gpItemPointer, TRUE);

        gfCheckForMouseOverItem = FALSE;

        // Highlight guys ....
        HandleAnyMercInSquadHasCompatibleStuff(CurrentSquad(), gpItemPointer, FALSE);
      } else {
        // InternalHandleCompatibleAmmoUI( gpSMCurrentMerc, gpItemPointer, FALSE );
        gfCheckForMouseOverItem = FALSE;

        HandleAnyMercInSquadHasCompatibleStuff(CurrentSquad(), NULL, TRUE);
      }

      if (fEnable) {
        ReevaluateItemHatches(gpSMCurrentMerc, fEnable);
      }

      fInterfacePanelDirty = DIRTYLEVEL2;
    }

    if (fEnable) {
      // only enable the following if NOT in shopkeeper's interface
      if (!(guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)) {
        EnableButton(iSMPanelButtons[CLIMB_BUTTON]);
        EnableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
        EnableButton(iSMPanelButtons[STANCEUP_BUTTON]);
        EnableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
        EnableButton(iSMPanelButtons[LOOK_BUTTON]);
        EnableButton(iSMPanelButtons[UPDOWN_BUTTON]);
        EnableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);
        if (giSMStealthButton != -1) {
          EnableButton(giSMStealthButton);
        }

        if (gfDisableTacticalPanelButtons) {
          DisableButton(iSMPanelButtons[OPTIONS_BUTTON]);
          DisableButton(iSMPanelButtons[SM_DONE_BUTTON]);
          DisableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
        } else {
          EnableButton(iSMPanelButtons[OPTIONS_BUTTON]);
          EnableButton(iSMPanelButtons[SM_DONE_BUTTON]);
          EnableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
        }

        // enable the radar map region
        MSYS_EnableRegion(addressof(gRadarRegion));

        gfSMDisableForItems = FALSE;

        DisableInvRegions(gfSMDisableForItems);
      }

      if (!fFromItemPickup) {
        EnableButton(iSMPanelButtons[NEXTMERC_BUTTON]);
        EnableButton(iSMPanelButtons[PREVMERC_BUTTON]);
      }
    } else {
      DisableButton(iSMPanelButtons[CLIMB_BUTTON]);
      DisableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
      DisableButton(iSMPanelButtons[STANCEUP_BUTTON]);
      DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
      DisableButton(iSMPanelButtons[LOOK_BUTTON]);
      DisableButton(iSMPanelButtons[UPDOWN_BUTTON]);
      DisableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);
      if (giSMStealthButton != -1) {
        DisableButton(giSMStealthButton);
      }

      if (!fFromItemPickup) {
        DisableButton(iSMPanelButtons[NEXTMERC_BUTTON]);
        DisableButton(iSMPanelButtons[PREVMERC_BUTTON]);
      }

      DisableButton(iSMPanelButtons[OPTIONS_BUTTON]);
      DisableButton(iSMPanelButtons[SM_DONE_BUTTON]);
      DisableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);

      // disable the radar map
      MSYS_DisableRegion(addressof(gRadarRegion));
    }

    gfAllDisabled = !fEnable;
  }
}

function GetSMPanelCurrentMerc(): UINT16 {
  return gusSMCurrentMerc;
}

function InitializeSMPanel(): BOOLEAN {
  let VObjectDesc: VOBJECT_DESC;

  // failing the CHECKF after this will cause you to lose your mouse
  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  strcpy(VObjectDesc.ImageFile, "INTERFACE\\inventory_bottom_panel.STI");
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiSMPanel)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\inventory_gold_front.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiSMObjects)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\inv_frn.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiSMObjects2)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\secondary_gun_hidden.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiSecItemHiddenVO)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\Bars.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiBrownBackgroundForTeamPanel)));

  // Clear inv display stuff
  memset(gfSM_HandInvDispText, 0, sizeof(gfSM_HandInvDispText));

  // INit viewport region
  // Set global mouse regions
  // Define region for viewport
  MSYS_DefineRegion(addressof(gViewportRegion), 0, 0, gsVIEWPORT_END_X, gsVIEWPORT_WINDOW_END_Y, MSYS_PRIORITY_NORMAL, VIDEO_NO_CURSOR, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(addressof(gViewportRegion));

  // Create buttons
  CHECKF(CreateSMPanelButtons());

  // Set viewports
  // Define region for panel
  MSYS_DefineRegion(addressof(gSMPanelRegion), 0, INV_INTERFACE_START_Y, 640, 480, MSYS_PRIORITY_NORMAL, CURSOR_NORMAL, MSYS_NO_CALLBACK, InvPanelButtonClickCallback);
  // Add region
  MSYS_AddRegion(addressof(gSMPanelRegion));

  // DEfine region for selected guy panel
  MSYS_DefineRegion(addressof(gSM_SELMERCPanelRegion), SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, SM_SELMERC_FACE_X + SM_SELMERC_FACE_WIDTH, SM_SELMERC_FACE_Y + SM_SELMERC_FACE_HEIGHT, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, SelectedMercButtonMoveCallback, SelectedMercButtonCallback);
  // Add region
  MSYS_AddRegion(addressof(gSM_SELMERCPanelRegion));

  // DEfine region for selected guy panel
  MSYS_DefineRegion(addressof(gSM_SELMERCEnemyIndicatorRegion), SM_SELMERC_FACE_X + 1, SM_SELMERC_FACE_Y + 1, SM_SELMERC_FACE_X + INDICATOR_BOX_WIDTH, SM_SELMERC_FACE_Y + INDICATOR_BOX_HEIGHT, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SelectedMercEnemyIndicatorCallback);
  // Add region
  MSYS_AddRegion(addressof(gSM_SELMERCEnemyIndicatorRegion));

  // DEfine region for money button
  MSYS_DefineRegion(addressof(gSM_SELMERCMoneyRegion), MONEY_X, MONEY_Y, MONEY_X + MONEY_WIDTH, MONEY_Y + MONEY_HEIGHT, MSYS_PRIORITY_HIGH, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SMInvMoneyButtonCallback);
  // Add region
  MSYS_AddRegion(addressof(gSM_SELMERCMoneyRegion));

  SetRegionFastHelpText(addressof(gSM_SELMERCMoneyRegion), TacticalStr[MONEY_BUTTON_HELP_TEXT]);

  // Check if mouse is in region and if so, adjust...
  if (IsMouseInRegion(addressof(gSM_SELMERCPanelRegion))) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, TRUE);
  }

  // DEfine region for selected guy panel
  MSYS_DefineRegion(addressof(gSM_SELMERCBarsRegion), 62, 342, 85, 391, MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, SelectedMercButtonCallback);
  // Add region
  MSYS_AddRegion(addressof(gSM_SELMERCBarsRegion));

  InitInvSlotInterface(gSMInvPocketXY, addressof(gSMCamoXY), SMInvMoveCallback, SMInvClickCallback, SMInvMoveCammoCallback, SMInvClickCamoCallback, FALSE);

  InitKeyRingInterface(KeyRingItemPanelButtonCallback);

  // this is important! It will disable buttons like SM_MAP_SCREEN_BUTTON when they're supposed to be disabled - the previous
  // disabled state is lost everytime panel is reinitialized, because all the buttons are created from scratch!
  if (gpItemPointer == NULL) {
    // empty cursor - enable, not from item pickup
    EnableSMPanelButtons(TRUE, FALSE);
  } else {
    // full cursor - disable, from item pickup
    EnableSMPanelButtons(FALSE, TRUE);
  }

  return TRUE;
}

function CreateSMPanelButtons(): BOOLEAN {
  let ubString: UINT8[] /* [48] */;

  giSMStealthImages = -1;
  giSMStealthButton = -1;
  gfUIStanceDifferent = TRUE;
  gfAllDisabled = FALSE;

  FilenameForBPP("INTERFACE\\inventory_buttons.sti", ubString);
  // Load button Graphics
  iSMPanelImages[STANCEUP_IMAGES] = LoadButtonImage(ubString, -1, 0, -1, 10, -1);

  iSMPanelImages[UPDOWN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 9, -1, 19, -1);
  iSMPanelImages[CLIMB_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 3, -1, 13, -1);
  iSMPanelImages[STANCEDOWN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 8, -1, 18, -1);
  iSMPanelImages[HANDCURSOR_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 1, -1, 11, -1);
  iSMPanelImages[PREVMERC_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 20, -1, 22, -1);
  iSMPanelImages[NEXTMERC_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 21, -1, 23, -1);
  // iSMPanelImages[ BURSTMODE_IMAGES  ]			= UseLoadedButtonImage( iSMPanelImages[ STANCEUP_IMAGES  ] ,-1,7,-1,17,-1 );
  iSMPanelImages[LOOK_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 2, -1, 12, -1);
  iSMPanelImages[TALK_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 6, -1, 16, -1);
  iSMPanelImages[MUTE_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 5, -1, 15, -1);
  iSMPanelImages[OPTIONS_IMAGES] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 24, -1, 25, -1);

  iBurstButtonImages[WM_NORMAL] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 7, -1, -1, -1);
  iBurstButtonImages[WM_BURST] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 17, -1, -1, -1);
  iBurstButtonImages[WM_ATTACHED] = UseLoadedButtonImage(iSMPanelImages[STANCEUP_IMAGES], -1, 26, -1, -1, -1);

  FilenameForBPP("INTERFACE\\invadd-ons.sti", ubString);
  // Load button Graphics
  iSMPanelImages[STANCE_IMAGES] = LoadButtonImage(ubString, 0, 0, -1, 2, -1);

  FilenameForBPP("INTERFACE\\inventory_buttons_2.sti", ubString);
  // Load button Graphics
  iSMPanelImages[DONE_IMAGES] = LoadButtonImage(ubString, -1, 1, -1, 3, -1);
  iSMPanelImages[MAPSCREEN_IMAGES] = UseLoadedButtonImage(iSMPanelImages[DONE_IMAGES], -1, 0, -1, 2, -1);

  // Create buttons

  // SET BUTTONS TO -1
  memset(iSMPanelButtons, -1, sizeof(iSMPanelButtons));

  iSMPanelButtons[SM_MAP_SCREEN_BUTTON] = QuickCreateButton(iSMPanelImages[MAPSCREEN_IMAGES], SM_MAPSCREEN_X, SM_MAPSCREEN_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnMapScreenCallback);
  SetButtonFastHelpText(iSMPanelButtons[SM_MAP_SCREEN_BUTTON], TacticalStr[MAPSCREEN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[SM_MAP_SCREEN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[SM_DONE_BUTTON] = CreateIconAndTextButton(iSMPanelImages[DONE_IMAGES], "", FONT12ARIAL, FONT_MCOLOR_WHITE, DEFAULT_SHADOW, FONT_MCOLOR_WHITE, DEFAULT_SHADOW, TEXT_CJUSTIFIED, SM_DONE_X, SM_DONE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnSMDoneCallback);
  SetButtonFastHelpText(iSMPanelButtons[SM_DONE_BUTTON], TacticalStr[END_TURN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[SM_DONE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[TALK_BUTTON] = QuickCreateButton(iSMPanelImages[TALK_IMAGES], SM_TALKB_X, SM_TALKB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnTalkCallback);
  SetButtonFastHelpText(iSMPanelButtons[TALK_BUTTON], TacticalStr[TALK_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[TALK_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[MUTE_BUTTON] = QuickCreateButton(iSMPanelImages[MUTE_IMAGES], SM_MUTEB_X, SM_MUTEB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnMuteCallback);
  SetButtonFastHelpText(iSMPanelButtons[MUTE_BUTTON], TacticalStr[TOGGLE_MUTE_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[MUTE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[STANCEUP_BUTTON] = QuickCreateButton(iSMPanelImages[STANCEUP_IMAGES], SM_STANCEUPB_X, SM_STANCEUPB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnStanceUpCallback);
  if (iSMPanelButtons[STANCEUP_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iSMPanelButtons[STANCEUP_BUTTON], TacticalStr[CHANGE_STANCE_UP_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[STANCEUP_BUTTON], HelpTextDoneCallback);

  // SetButtonFastHelpText( iSMPanelButtons[ STANCEUP_BUTTON ],L"Change Stance Up");

  iSMPanelButtons[UPDOWN_BUTTON] = QuickCreateButton(iSMPanelImages[UPDOWN_IMAGES], SM_UPDOWNB_X, SM_UPDOWNB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnUpdownCallback);
  if (iSMPanelButtons[UPDOWN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ UPDOWN_BUTTON ],L"Whatever");
  SetButtonFastHelpText(iSMPanelButtons[UPDOWN_BUTTON], TacticalStr[CURSOR_LEVEL_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[UPDOWN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[CLIMB_BUTTON] = QuickCreateButton(iSMPanelImages[CLIMB_IMAGES], SM_CLIMBB_X, SM_CLIMBB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnClimbCallback);
  if (iSMPanelButtons[CLIMB_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ CLIMB_BUTTON ],L"Climb");
  SetButtonFastHelpText(iSMPanelButtons[CLIMB_BUTTON], TacticalStr[JUMPCLIMB_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[CLIMB_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[STANCEDOWN_BUTTON] = QuickCreateButton(iSMPanelImages[STANCEDOWN_IMAGES], SM_STANCEDOWNB_X, SM_STANCEDOWNB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnStanceDownCallback);
  if (iSMPanelButtons[STANCEDOWN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ STANCEDOWN_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[STANCEDOWN_BUTTON], TacticalStr[CHANGE_STANCE_DOWN_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[STANCEDOWN_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[HANDCURSOR_BUTTON] = QuickCreateButton(iSMPanelImages[HANDCURSOR_IMAGES], SM_HANDCURSORB_X, SM_HANDCURSORB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnHandCursorCallback);
  if (iSMPanelButtons[HANDCURSOR_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ HANDCURSOR_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[HANDCURSOR_BUTTON], TacticalStr[EXAMINE_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[HANDCURSOR_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[PREVMERC_BUTTON] = QuickCreateButton(iSMPanelImages[PREVMERC_IMAGES], SM_PREVMERCB_X, SM_PREVMERCB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnPrevMercCallback);
  if (iSMPanelButtons[PREVMERC_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ PREVMERC_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[PREVMERC_BUTTON], TacticalStr[PREV_MERC_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[PREVMERC_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[NEXTMERC_BUTTON] = QuickCreateButton(iSMPanelImages[NEXTMERC_IMAGES], SM_NEXTMERCB_X, SM_NEXTMERCB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnNextMercCallback);
  if (iSMPanelButtons[NEXTMERC_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iSMPanelButtons[NEXTMERC_BUTTON], TacticalStr[NEXT_MERC_POPUPTEXT]);
  // SetButtonFastHelpText( iSMPanelButtons[ NEXTMERC_BUTTON ],L"Change Stance Down");
  SetBtnHelpEndCallback(iSMPanelButtons[NEXTMERC_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[OPTIONS_BUTTON] = QuickCreateButton(iSMPanelImages[OPTIONS_IMAGES], SM_OPTIONSB_X, SM_OPTIONSB_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnOptionsCallback);
  if (iSMPanelButtons[OPTIONS_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ OPTIONS_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[OPTIONS_BUTTON], TacticalStr[CHANGE_OPTIONS_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[OPTIONS_BUTTON], HelpTextDoneCallback);

  /*iSMPanelButtons[ BURSTMODE_BUTTON ] = QuickCreateButton( iSMPanelImages[ BURSTMODE_IMAGES ], SM_BURSTMODEB_X, SM_BURSTMODEB_Y,
                                                                          BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1,
                                                                          MSYS_NO_CALLBACK, (GUI_CALLBACK)BtnBurstModeCallback );*/
  iSMPanelButtons[BURSTMODE_BUTTON] = QuickCreateButton(iBurstButtonImages[WM_NORMAL], SM_BURSTMODEB_X, SM_BURSTMODEB_Y, BUTTON_NO_TOGGLE, MSYS_PRIORITY_HIGH, MSYS_NO_CALLBACK, BtnBurstModeCallback);

  if (iSMPanelButtons[BURSTMODE_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iSMPanelButtons[BURSTMODE_BUTTON], TacticalStr[TOGGLE_BURSTMODE_POPUPTEXT]);
  // SetButtonFastHelpText( iSMPanelButtons[ BURSTMODE_BUTTON ],L"Change Stance Down");
  SetBtnHelpEndCallback(iSMPanelButtons[BURSTMODE_BUTTON], HelpTextDoneCallback);

  iSMPanelButtons[LOOK_BUTTON] = QuickCreateButton(iSMPanelImages[LOOK_IMAGES], SM_LOOKB_X, SM_LOOKB_Y, BUTTON_NEWTOGGLE, MSYS_PRIORITY_HIGH - 1, MSYS_NO_CALLBACK, BtnLookCallback);
  if (iSMPanelButtons[LOOK_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  // SetButtonFastHelpText( iSMPanelButtons[ LOOK_BUTTON ],L"Change Stance Down");
  SetButtonFastHelpText(iSMPanelButtons[LOOK_BUTTON], TacticalStr[LOOK_CURSOR_POPUPTEXT]);
  SetBtnHelpEndCallback(iSMPanelButtons[LOOK_BUTTON], HelpTextDoneCallback);

  return TRUE;
}

function RemoveSMPanelButtons(): void {
  let cnt: UINT32;

  for (cnt = 0; cnt < NUM_SM_BUTTONS; cnt++) {
    if (iSMPanelButtons[cnt] != -1) {
      RemoveButton(iSMPanelButtons[cnt]);
    }
  }

  for (cnt = 0; cnt < NUM_SM_BUTTON_IMAGES; cnt++) {
    UnloadButtonImage(iSMPanelImages[cnt]);
  }

  if (giSMStealthButton != -1) {
    RemoveButton(giSMStealthButton);
  }

  if (giSMStealthImages != -1) {
    UnloadButtonImage(giSMStealthImages);
  }

  UnloadButtonImage(iBurstButtonImages[WM_NORMAL]);
  UnloadButtonImage(iBurstButtonImages[WM_BURST]);
  UnloadButtonImage(iBurstButtonImages[WM_ATTACHED]);
}

function ShutdownSMPanel(): BOOLEAN {
  // All buttons and regions and video objects and video surfaces will be deleted at shutddown of SGM
  // We may want to delete them at the interm as well, to free up room for other panels
  DeleteVideoObjectFromIndex(guiSMPanel);
  DeleteVideoObjectFromIndex(guiSMObjects);
  DeleteVideoObjectFromIndex(guiSMObjects2);
  DeleteVideoObjectFromIndex(guiSecItemHiddenVO);
  DeleteVideoObjectFromIndex(guiBrownBackgroundForTeamPanel);

  gubSelectSMPanelToMerc = NOBODY;

  // CJC: delete key ring if open
  DeleteKeyRingPopup(); // function will abort if key ring is not up

  // ATE: Delete desc panel if it was open....
  if (gfInItemDescBox) {
    DeleteItemDescriptionBox();
  }

  // Shotdown item slot interface
  ShutdownInvSlotInterface();

  // shutdown keyring interface
  ShutdownKeyRingInterface();

  MSYS_RemoveRegion(addressof(gSMPanelRegion));
  MSYS_RemoveRegion(addressof(gSM_SELMERCPanelRegion));
  MSYS_RemoveRegion(addressof(gSM_SELMERCBarsRegion));
  MSYS_RemoveRegion(addressof(gSM_SELMERCMoneyRegion));
  MSYS_RemoveRegion(addressof(gSM_SELMERCEnemyIndicatorRegion));

  HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, FALSE);

  MSYS_RemoveRegion(addressof(gViewportRegion));

  RemoveSMPanelButtons();

  return TRUE;
}

function RenderSMPanel(pfDirty: Pointer<BOOLEAN>): void {
  let sFontX: INT16;
  let sFontY: INT16;
  let usX: UINT16;
  let usY: UINT16;
  let sString: wchar_t[] /* [9] */;
  let cnt: UINT32;
  /* static */ let pStr: INT16[] /* [200] */;
  /* static */ let pMoraleStr: INT16[] /* [20] */;

  if (gubSelectSMPanelToMerc != NOBODY) {
    // Give him the panel!
    SetSMPanelCurrentMerc(gubSelectSMPanelToMerc);
  }

  // ATE: Don't do anything if we are in stack popup and are refreshing stuff....
  if ((InItemStackPopup() || (InKeyRingPopup())) && (*pfDirty) == DIRTYLEVEL1) {
    return;
  }

  if (gfCheckForMouseOverItem) {
    if ((GetJA2Clock() - guiMouseOverItemTime) > 100) {
      if (HandleCompatibleAmmoUI(gpSMCurrentMerc, gbCheckForMouseOverItemPos, TRUE)) {
        (*pfDirty) = DIRTYLEVEL2;
      }

      gfCheckForMouseOverItem = FALSE;
    }
  }

  HandleNewlyAddedItems(gpSMCurrentMerc, pfDirty);

  if (InItemDescriptionBox()) {
    HandleItemDescriptionBox(pfDirty);
  }

  if (*pfDirty == DIRTYLEVEL2) {
    // if ( InItemStackPopup( ) )
    //{

    //}

    if (InItemDescriptionBox()) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL);
      RenderSoldierFace(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, TRUE);

      // ATE: Need these lines here to fix flash bug with face selection box
      if (gfSMDisableForItems) {
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects2, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, NULL);
        RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
      } else {
        if (gusSelectedSoldier == gpSMCurrentMerc.value.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(gpSMCurrentMerc)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, NULL);
          RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
        }
      }

      RenderItemDescriptionBox();
    } else {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMPanel, 0, INTERFACE_START_X, INV_INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL);

      RenderInvBodyPanel(gpSMCurrentMerc, SM_BODYINV_X, SM_BODYINV_Y);

      // CHECK FOR PANEL STUFF / DEATHS / CLOSURES
      CheckForFacePanelStartAnims(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y);

      // Hitlight

      if (gfSMDisableForItems) {
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects2, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, NULL);
        RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
      } else {
        if (gusSelectedSoldier == gpSMCurrentMerc.value.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(gpSMCurrentMerc)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiSMObjects, 0, SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, VO_BLT_SRCTRANSPARENCY, NULL);
          RestoreExternBackgroundRect(SM_SELMERC_PLATE_X, SM_SELMERC_PLATE_Y, SM_SELMERC_PLATE_WIDTH, SM_SELMERC_PLATE_HEIGHT);
        }
      }

      // Render faceplate
      // BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMObjects2, 1, SM_SELMERC_NAMEPLATE_X, SM_SELMERC_NAMEPLATE_Y, VO_BLT_SRCTRANSPARENCY, NULL );
      // RestoreExternBackgroundRect( SM_SELMERC_NAMEPLATE_X, SM_SELMERC_NAMEPLATE_Y, SM_SELMERC_NAMEPLATE_WIDTH, SM_SELMERC_NAMEPLATE_HEIGHT );

      // Blit position
      // if(gbPixelDepth==16)
      //{
      // BltVideoObjectFromIndex( guiSAVEBUFFER, guiSMObjects, gbSMCurStanceObj, SM_POSITIONB_X, SM_POSITIONB_Y, VO_BLT_SRCTRANSPARENCY, NULL );
      //}
      // RestoreExternBackgroundRect( SM_POSITIONB_X, SM_POSITIONB_Y, SM_POSITIONB_WIDTH , SM_POSITIONB_HEIGHT );

      SetFont(BLOCKFONT2);

      // Render Values for stats!
      // Set font drawing to saved buffer
      SetFontDestBuffer(guiSAVEBUFFER, 0, 0, 640, 480, FALSE);

      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(STATS_TITLE_FONT_COLOR);
      for (cnt = 0; cnt < 5; cnt++) {
        mprintf(92, (347 + cnt * 10), pShortAttributeStrings[cnt]);
        mprintf(137, (347 + cnt * 10), pShortAttributeStrings[cnt + 5]);
      }

      mprintf(SM_ARMOR_LABEL_X - StringPixLength(pInvPanelTitleStrings[0], BLOCKFONT2) / 2, SM_ARMOR_LABEL_Y, pInvPanelTitleStrings[0]);
      mprintf(SM_ARMOR_PERCENT_X, SM_ARMOR_PERCENT_Y, "%%");

      mprintf(SM_WEIGHT_LABEL_X - StringPixLength(pInvPanelTitleStrings[1], BLOCKFONT2), SM_WEIGHT_LABEL_Y, pInvPanelTitleStrings[1]);
      mprintf(SM_WEIGHT_PERCENT_X, SM_WEIGHT_PERCENT_Y, "%%");

      mprintf(SM_CAMMO_LABEL_X - StringPixLength(pInvPanelTitleStrings[2], BLOCKFONT2), SM_CAMMO_LABEL_Y, pInvPanelTitleStrings[2]);
      mprintf(SM_CAMMO_PERCENT_X, SM_CAMMO_PERCENT_Y, "%%");

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeAgilityTime, (gpSMCurrentMerc.value.usValueGoneUp & AGIL_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bAgility);
      FindFontRightCoordinates(SM_AGI_X, SM_AGI_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeDexterityTime, (gpSMCurrentMerc.value.usValueGoneUp & DEX_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bDexterity);
      FindFontRightCoordinates(SM_DEX_X, SM_DEX_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeStrengthTime, (gpSMCurrentMerc.value.usValueGoneUp & STRENGTH_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bStrength);
      FindFontRightCoordinates(SM_STR_X, SM_STR_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeLeadershipTime, (gpSMCurrentMerc.value.usValueGoneUp & LDR_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bLeadership);
      FindFontRightCoordinates(SM_CHAR_X, SM_CHAR_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeWisdomTime, (gpSMCurrentMerc.value.usValueGoneUp & WIS_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bWisdom);
      FindFontRightCoordinates(SM_WIS_X, SM_WIS_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeLevelTime, (gpSMCurrentMerc.value.usValueGoneUp & LVL_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bExpLevel);
      FindFontRightCoordinates(SM_EXPLVL_X, SM_EXPLVL_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeMarksmanshipTime, (gpSMCurrentMerc.value.usValueGoneUp & MRK_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bMarksmanship);
      FindFontRightCoordinates(SM_MRKM_X, SM_MRKM_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeExplosivesTime, (gpSMCurrentMerc.value.usValueGoneUp & EXP_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bExplosive);
      FindFontRightCoordinates(SM_EXPL_X, SM_EXPL_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeMechanicalTime, (gpSMCurrentMerc.value.usValueGoneUp & MECH_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bMechanical);
      FindFontRightCoordinates(SM_MECH_X, SM_MECH_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      UpdateStatColor(gpSMCurrentMerc.value.uiChangeMedicalTime, (gpSMCurrentMerc.value.usValueGoneUp & MED_INCREASE ? TRUE : FALSE));

      swprintf(sString, "%2d", gpSMCurrentMerc.value.bMedical);
      FindFontRightCoordinates(SM_MED_X, SM_MED_Y, SM_STATS_WIDTH, SM_STATS_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      if (gpSMCurrentMerc.value.bLife >= OKLIFE) {
        SetFontBackground(FONT_MCOLOR_BLACK);
        SetFontForeground(STATS_TEXT_FONT_COLOR);
      } else {
        SetFontBackground(FONT_MCOLOR_BLACK);
        SetFontForeground(FONT_MCOLOR_DKGRAY);
      }

      // Display armour value!
      swprintf(sString, "%3d", ArmourPercent(gpSMCurrentMerc));
      FindFontRightCoordinates(SM_ARMOR_X, SM_ARMOR_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      // Display wieght value!
      swprintf(sString, "%3d", CalculateCarriedWeight(gpSMCurrentMerc));
      FindFontRightCoordinates(SM_WEIGHT_X, SM_WEIGHT_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      // Display cammo value!
      swprintf(sString, "%3d", gpSMCurrentMerc.value.bCamo);
      FindFontRightCoordinates(SM_CAMMO_X, SM_CAMMO_Y, SM_PERCENT_WIDTH, SM_PERCENT_HEIGHT, sString, BLOCKFONT2, addressof(usX), addressof(usY));
      mprintf(usX, usY, sString);

      // reset to frame buffer!
      SetFontDestBuffer(FRAME_BUFFER, 0, 0, 640, 480, FALSE);

      RestoreExternBackgroundRect(INTERFACE_START_X, INV_INTERFACE_START_Y, (640 - INTERFACE_START_X), (480 - INV_INTERFACE_START_Y));

      RenderSoldierFace(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, TRUE);
    }

    // Render Name!
    SetFont(BLOCKFONT2);

    if (gpSMCurrentMerc.value.bStealthMode) {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(FONT_MCOLOR_LTYELLOW);
    } else {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(FONT_MCOLOR_LTGRAY);
    }

    RestoreExternBackgroundRect(SM_SELMERCNAME_X, SM_SELMERCNAME_Y, SM_SELMERCNAME_WIDTH, SM_SELMERCNAME_HEIGHT);
    VarFindFontCenterCoordinates(SM_SELMERCNAME_X, SM_SELMERCNAME_Y, SM_SELMERCNAME_WIDTH, SM_SELMERCNAME_HEIGHT, SMALLFONT1, addressof(sFontX), addressof(sFontY), "%s", gpSMCurrentMerc.value.name);
    mprintf(sFontX + 5, sFontY, "%s", gpSMCurrentMerc.value.name);
  }

  if (*pfDirty != DIRTYLEVEL0) {
    // UPdate stats!
    if (gpSMCurrentMerc.value.bLife != 0) {
      if (gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_VEHICLE) {
        swprintf(pStr, TacticalStr[VEHICLE_VITAL_STATS_POPUPTEXT], gpSMCurrentMerc.value.bLife, gpSMCurrentMerc.value.bLifeMax, gpSMCurrentMerc.value.bBreath, gpSMCurrentMerc.value.bBreathMax);
        SetRegionFastHelpText(addressof(gSM_SELMERCBarsRegion), pStr);
      } else if (gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_ROBOT) {
        swprintf(pStr, gzLateLocalizedString[16], gpSMCurrentMerc.value.bLife, gpSMCurrentMerc.value.bLifeMax);
        SetRegionFastHelpText(addressof(gTEAM_BarsRegions[cnt]), pStr);
      } else {
        GetMoraleString(gpSMCurrentMerc, pMoraleStr);
        swprintf(pStr, TacticalStr[MERC_VITAL_STATS_POPUPTEXT], gpSMCurrentMerc.value.bLife, gpSMCurrentMerc.value.bLifeMax, gpSMCurrentMerc.value.bBreath, gpSMCurrentMerc.value.bBreathMax, pMoraleStr);
        SetRegionFastHelpText(addressof(gSM_SELMERCBarsRegion), pStr);
      }
    } else {
      SetRegionFastHelpText(addressof(gSM_SELMERCBarsRegion), "");
    }

    // if we are in the shop keeper interface
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
      SetRegionHelpEndCallback(addressof(gSM_SELMERCBarsRegion), SkiHelpTextDoneCallBack);

    // display AP
    if (!(gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_DEAD)) {
      if (gTacticalStatus.uiFlags & TURNBASED && (gTacticalStatus.uiFlags & INCOMBAT) && gpSMCurrentMerc.value.bLife >= OKLIFE) {
        SetFont(TINYFONT1);
        // if ( gpSMCurrentMerc->sLastTarget != NOWHERE && !EnoughPoints( gpSMCurrentMerc, MinAPsToAttack( gpSMCurrentMerc, gpSMCurrentMerc->sLastTarget, FALSE ), 0, FALSE ) || GetUIApsToDisplay( gpSMCurrentMerc ) < 0 )
        if (!EnoughPoints(gpSMCurrentMerc, MinAPsToAttack(gpSMCurrentMerc, gpSMCurrentMerc.value.sLastTarget, FALSE), 0, FALSE) || GetUIApsToDisplay(gpSMCurrentMerc) < 0) {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_DKRED);
        } else {
          if (MercUnderTheInfluence(gpSMCurrentMerc)) {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTBLUE);
          } else if (gpSMCurrentMerc.value.bStealthMode) {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTYELLOW);
          } else {
            SetFontBackground(FONT_MCOLOR_BLACK);
            SetFontForeground(FONT_MCOLOR_LTGRAY);
          }
        }

        gprintfRestore(SM_SELMERC_AP_X, SM_SELMERC_AP_Y, "%2d", GetUIApsToDisplay(gpSMCurrentMerc));
        VarFindFontCenterCoordinates(SM_SELMERC_AP_X, SM_SELMERC_AP_Y, SM_SELMERC_AP_WIDTH, SM_SELMERC_AP_HEIGHT, TINYFONT1, addressof(sFontX), addressof(sFontY), "%d", GetUIApsToDisplay(gpSMCurrentMerc));
        mprintf(sFontX, SM_SELMERC_AP_Y, "%d", GetUIApsToDisplay(gpSMCurrentMerc));
      }

      // Display bars
      DrawLifeUIBarEx(gpSMCurrentMerc, SM_SELMERC_HEALTH_X, SM_SELMERC_HEALTH_Y, SM_SELMERC_HEALTH_WIDTH, SM_SELMERC_HEALTH_HEIGHT, TRUE, FRAME_BUFFER);

      if (!(gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_ROBOT)) {
        DrawBreathUIBarEx(gpSMCurrentMerc, SM_SELMERC_BREATH_X, SM_SELMERC_BREATH_Y, SM_SELMERC_HEALTH_WIDTH, SM_SELMERC_HEALTH_HEIGHT, TRUE, FRAME_BUFFER);
        DrawMoraleUIBarEx(gpSMCurrentMerc, SM_SELMERC_MORALE_X, SM_SELMERC_MORALE_Y, SM_SELMERC_MORALE_WIDTH, SM_SELMERC_MORALE_HEIGHT, TRUE, FRAME_BUFFER);
      }
    }
  }

  UpdateSMPanel();

  // HandlePanelFaceAnimations( gpSMCurrentMerc );

  HandleSoldierFaceFlash(gpSMCurrentMerc, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y);

  // Render items in guy's hand!
  HandleRenderInvSlots(gpSMCurrentMerc, *pfDirty);

  if (gfSMDisableForItems && (*pfDirty) != DIRTYLEVEL0) {
    let pDestBuf: Pointer<UINT8>;
    let uiDestPitchBYTES: UINT32;
    let ClipRect: SGPRect;

    ClipRect.iLeft = 87;
    ClipRect.iRight = 536;
    ClipRect.iTop = INV_INTERFACE_START_Y;
    ClipRect.iBottom = 480;
    pDestBuf = LockVideoSurface(FRAME_BUFFER, addressof(uiDestPitchBYTES));
    Blt16BPPBufferHatchRect(pDestBuf, uiDestPitchBYTES, addressof(ClipRect));
    UnLockVideoSurface(FRAME_BUFFER);
  }
}

function UpdateStatColor(uiTimer: UINT32, fIncrease: BOOLEAN): void {
  if (gpSMCurrentMerc.value.bLife >= OKLIFE) {
    if ((GetJA2Clock() < CHANGE_STAT_RECENTLY_DURATION + uiTimer) && (uiTimer != 0)) {
      if (fIncrease) {
        SetFontForeground(FONT_LTGREEN);
      } else {
        SetFontForeground(FONT_RED);
      }
    } else {
      SetFontBackground(FONT_MCOLOR_BLACK);
      SetFontForeground(STATS_TEXT_FONT_COLOR);
    }
  } else {
    SetFontBackground(FONT_MCOLOR_BLACK);
    SetFontForeground(FONT_MCOLOR_DKGRAY);
  }
}

function SMInvMoveCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let uiHandPos: UINT32;

  uiHandPos = MSYS_GetRegionUserData(pRegion, 0);

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (gpSMCurrentMerc.value.inv[uiHandPos].usItem == NOTHING)
    return;

  if (iReason == MSYS_CALLBACK_REASON_MOVE) {
  } else if (iReason == MSYS_CALLBACK_REASON_GAIN_MOUSE) {
    if (gpItemPointer == NULL) {
      // Setup a timer....
      guiMouseOverItemTime = GetJA2Clock();
      gfCheckForMouseOverItem = TRUE;
      gbCheckForMouseOverItemPos = uiHandPos;
    }
  }
  if (iReason == MSYS_CALLBACK_REASON_LOST_MOUSE) {
    // gfSM_HandInvDispText[ uiHandPos ] = 1;
    if (gpItemPointer == NULL) {
      HandleCompatibleAmmoUI(gpSMCurrentMerc, uiHandPos, FALSE);
      gfCheckForMouseOverItem = FALSE;
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  }
}

function InvPanelButtonClickCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

function SMInvMoveCammoCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  } else if (iReason == MSYS_CALLBACK_REASON_GAIN_MOUSE) {
    // Setup a timer....
    guiMouseOverItemTime = GetJA2Clock();
    gfCheckForMouseOverItem = TRUE;
    gbCheckForMouseOverItemPos = NO_SLOT;
  }
  if (iReason == MSYS_CALLBACK_REASON_LOST_MOUSE) {
    // gfSM_HandInvDispText[ uiHandPos ] = 1;
    HandleCompatibleAmmoUI(gpSMCurrentMerc, NO_SLOT, FALSE);
    gfCheckForMouseOverItem = FALSE;
  }
}

function SMInvClickCamoCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  // UINT16 usNewItemIndex;
  let ubSrcID: UINT8;
  let ubDestID: UINT8;
  let fGoodAPs: BOOLEAN;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // Apply camo ( if we have something in cursor... )
    // If we do not have an item in hand, start moving it
    if (gpItemPointer != NULL) {
      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gpSMCurrentMerc.value.ubID;
      ubDestID = gpItemPointerSoldier.value.ubID;

      // if ( ubSrcID == ubDestID )
      {
        // We are doing this ourselve, continue
        if (gpSMCurrentMerc.value.bLife >= CONSCIOUSNESS) {
          // usNewItemIndex = gpItemPointer->usItem;

          // Try to apply camo....
          if (ApplyCammo(gpSMCurrentMerc, gpItemPointer, addressof(fGoodAPs))) {
            if (fGoodAPs) {
              // Dirty
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.value.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = FALSE;
                EndItemPointer();
              }

              // Say OK acknowledge....
              DoMercBattleSound(gpSMCurrentMerc, BATTLE_SOUND_COOL1);
            }
          } else if (ApplyCanteen(gpSMCurrentMerc, gpItemPointer, addressof(fGoodAPs))) {
            // Dirty
            if (fGoodAPs) {
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.value.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = FALSE;
                EndItemPointer();
              }
            }
          } else if (ApplyElixir(gpSMCurrentMerc, gpItemPointer, addressof(fGoodAPs))) {
            if (fGoodAPs) {
              // Dirty
              fInterfacePanelDirty = DIRTYLEVEL2;

              // Check if it's the same now!
              if (gpItemPointer.value.ubNumberOfObjects == 0) {
                gbCompatibleApplyItem = FALSE;
                EndItemPointer();
              }

              // Say OK acknowledge....
              DoMercBattleSound(gpSMCurrentMerc, BATTLE_SOUND_COOL1);
            }
          } else if (ApplyDrugs(gpSMCurrentMerc, gpItemPointer)) {
            // Dirty
            fInterfacePanelDirty = DIRTYLEVEL2;

            // Check if it's the same now!
            if (gpItemPointer.value.ubNumberOfObjects == 0) {
              gbCompatibleApplyItem = FALSE;
              EndItemPointer();
            }

            /*
            // COMMENTED OUT DUE TO POTENTIAL SERIOUS PROBLEMS WITH STRATEGIC EVENT SYSTEM

            if ( gpSMCurrentMerc->ubProfile == LARRY_NORMAL )
            {
                    // Larry's taken something!
                    gpSMCurrentMerc = SwapLarrysProfiles( gpSMCurrentMerc );
            }
            */

            // Say OK acknowledge....
            DoMercBattleSound(gpSMCurrentMerc, BATTLE_SOUND_COOL1);
          } else {
            // Send message
            ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_UI_FEEDBACK, TacticalStr[CANNOT_DO_INV_STUFF_STR]);
          }
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

function HandleNailsVestFetish(pSoldier: Pointer<SOLDIERTYPE>, uiHandPos: UINT32, usReplaceItem: UINT16): BOOLEAN {
  let fRefuse: BOOLEAN = FALSE;

  // OK are we nails?
  if (pSoldier.value.ubProfile == 34) {
    // if this the VEST POS?
    if (uiHandPos == VESTPOS) {
      // Are we trying to pick it up?
      if (usReplaceItem == NOTHING) {
        fRefuse = TRUE;
      } else {
        // Do we have nothing or the leather vest or kevlar leather vest?
        if (usReplaceItem == LEATHER_JACKET || usReplaceItem == LEATHER_JACKET_W_KEVLAR || usReplaceItem == LEATHER_JACKET_W_KEVLAR_18 || usReplaceItem == LEATHER_JACKET_W_KEVLAR_Y || usReplaceItem == COMPOUND18 || usReplaceItem == JAR_QUEEN_CREATURE_BLOOD) {
          // This is good....
          fRefuse = FALSE;
        } else {
          fRefuse = TRUE;
        }
      }

      if (fRefuse) {
        // Say quote!
        TacticalCharacterDialogue(pSoldier, 61);
        return TRUE;
      }
    }
  }

  return FALSE;
}

function UIHandleItemPlacement(ubHandPos: UINT8, usOldItemIndex: UINT16, usNewItemIndex: UINT16, fDeductPoints: BOOLEAN): BOOLEAN {
  if (_KeyDown(CTRL)) {
    CleanUpStack(addressof(gpSMCurrentMerc.value.inv[ubHandPos]), gpItemPointer);
    if (gpItemPointer.value.ubNumberOfObjects == 0) {
      EndItemPointer();
    }
    return TRUE;
  }

  // Try to place here
  if (PlaceObject(gpSMCurrentMerc, ubHandPos, gpItemPointer)) {
    if (fDeductPoints) {
      // Deduct points
      if (gpItemPointerSoldier.value.bLife >= CONSCIOUSNESS) {
        DeductPoints(gpItemPointerSoldier, 2, 0);
      }
      if (gpSMCurrentMerc.value.bLife >= CONSCIOUSNESS) {
        DeductPoints(gpSMCurrentMerc, 2, 0);
      }
    }

    HandleTacticalEffectsOfEquipmentChange(gpSMCurrentMerc, ubHandPos, usOldItemIndex, usNewItemIndex);

    // Dirty
    fInterfacePanelDirty = DIRTYLEVEL2;

    // Check if cursor is empty now
    if (gpItemPointer.value.ubNumberOfObjects == 0) {
      EndItemPointer();
    }

    if (gpItemPointerSoldier != gpSMCurrentMerc) {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, pMessageStrings[MSG_ITEM_PASSED_TO_MERC], ShortItemNames[usNewItemIndex], gpSMCurrentMerc.value.name);
    }

    // UPDATE ITEM POINTER.....
    gpItemPointerSoldier = gpSMCurrentMerc;

    if (gpItemPointer != NULL) {
      ReevaluateItemHatches(gpSMCurrentMerc, FALSE);
    }

    // Set cursor back to normal mode...
    guiPendingOverrideEvent = A_CHANGE_TO_MOVE;

    return TRUE;
  } else {
    return FALSE;
  }
}

function SMInvClickCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let uiHandPos: UINT32;
  // Copyies of values
  let usOldItemIndex: UINT16;
  let usNewItemIndex: UINT16;
  let usItemPrevInItemPointer: UINT16;
  let fNewItem: BOOLEAN = FALSE;
  /* static */ let fRightDown: BOOLEAN = FALSE;
  /* static */ let fLeftDown: BOOLEAN = FALSE;

  uiHandPos = MSYS_GetRegionUserData(pRegion, 0);

  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
    // and this inventory slot is hatched out
    if (ShouldSoldierDisplayHatchOnItem(gpSMCurrentMerc.value.ubProfile, uiHandPos)) {
      // it means that item is a copy of one in the player's offer area, so we treat it as if the slot was empty (ignore)
      // if the cursor has an item in it, we still ignore the click, because handling swaps in this situation would be
      // ugly, we'd have to the the swap, then make the bOwnerSlot of the item just picked up a -1 in its offer area spot.
      return;
    }
  }

  // if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
  //{
  //	fLeftDown = TRUE;
  //}
  // else if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP && fLeftDown )
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    fLeftDown = FALSE;

    // If we do not have an item in hand, start moving it
    if (gpItemPointer == NULL) {
      // Return if empty
      if (gpSMCurrentMerc.value.inv[uiHandPos].usItem == NOTHING)
        return;

      if (gpSMCurrentMerc.value.ubID != gusSelectedSoldier) {
        SelectSoldier(gpSMCurrentMerc.value.ubID, FALSE, FALSE);
      }

      // OK, check if this is Nails, and we're in the vest position , don't allow it to come off....
      if (HandleNailsVestFetish(gpSMCurrentMerc, uiHandPos, NOTHING)) {
        return;
      }

      if (_KeyDown(CTRL)) {
        CleanUpStack(addressof(gpSMCurrentMerc.value.inv[uiHandPos]), NULL);
        return;
      }

      // Turn off new item glow!
      gpSMCurrentMerc.value.bNewItemCount[uiHandPos] = 0;

      usOldItemIndex = gpSMCurrentMerc.value.inv[uiHandPos].usItem;

      // move item into the mouse cursor
      BeginItemPointer(gpSMCurrentMerc, uiHandPos);

      // if we are in the shopkeeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        // pick up item from regular inventory slot into cursor OR try to sell it ( unless CTRL is held down )
        BeginSkiItemPointer(PLAYERS_INVENTORY, uiHandPos, !gfKeyState[CTRL]);
      }

      HandleTacticalEffectsOfEquipmentChange(gpSMCurrentMerc, uiHandPos, usOldItemIndex, NOTHING);

      // HandleCompatibleAmmoUI( gpSMCurrentMerc, (INT8)uiHandPos, FALSE );
    } else // item in cursor
    {
      let ubSrcID: UINT8;
      let ubDestID: UINT8;
      let fOKToGo: BOOLEAN = FALSE;
      let fDeductPoints: BOOLEAN = FALSE;

      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gpSMCurrentMerc.value.ubID;
      ubDestID = gpItemPointerSoldier.value.ubID;

      if (ubSrcID == ubDestID) {
        // We are doing this ourselve, continue
        fOKToGo = TRUE;
      } else {
        // These guys are different....
        fDeductPoints = TRUE;

        // First check points for src guy
        if (gpItemPointerSoldier.value.bLife >= CONSCIOUSNESS) {
          if (EnoughPoints(gpItemPointerSoldier, 3, 0, TRUE)) {
            fOKToGo = TRUE;
          }
        } else {
          fOKToGo = TRUE;
        }

        // Should we go on?
        if (fOKToGo) {
          if (gpSMCurrentMerc.value.bLife >= CONSCIOUSNESS) {
            if (EnoughPoints(gpSMCurrentMerc, 3, 0, TRUE)) {
              fOKToGo = TRUE;
            } else {
              fOKToGo = FALSE;
            }
          }
        }
      }

      if (fOKToGo) {
        // OK, check if this is Nails, and we're in the vest position , don't allow it to come off....
        if (HandleNailsVestFetish(gpSMCurrentMerc, uiHandPos, gpItemPointer.value.usItem)) {
          return;
        }

        usOldItemIndex = gpSMCurrentMerc.value.inv[uiHandPos].usItem;
        usNewItemIndex = gpItemPointer.value.usItem;

        if (uiHandPos == HANDPOS || uiHandPos == SECONDHANDPOS || uiHandPos == HELMETPOS || uiHandPos == VESTPOS || uiHandPos == LEGPOS) {
          // if ( ValidAttachmentClass( usNewItemIndex, usOldItemIndex ) )
          if (ValidAttachment(usNewItemIndex, usOldItemIndex)) {
            // it's an attempt to attach; bring up the inventory panel
            if (!InItemDescriptionBox()) {
              InitItemDescriptionBox(gpSMCurrentMerc, uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
            }
            return;
          } else if (ValidMerge(usNewItemIndex, usOldItemIndex)) {
            // bring up merge requestor
            gubHandPos = uiHandPos;
            gusOldItemIndex = usOldItemIndex;
            gusNewItemIndex = usNewItemIndex;
            gfDeductPoints = fDeductPoints;

            if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
              // the only way to merge items is to pick them up.  In SKI when you pick up an item, the cursor is
              // locked in a region, free it up.
              FreeMouseCursor();

              DoMessageBox(MSG_BOX_BASIC_STYLE, Message[STR_MERGE_ITEMS], SHOPKEEPER_SCREEN, MSG_BOX_FLAG_YESNO, MergeMessageBoxCallBack, NULL);
            } else
              DoMessageBox(MSG_BOX_BASIC_STYLE, Message[STR_MERGE_ITEMS], GAME_SCREEN, MSG_BOX_FLAG_YESNO, MergeMessageBoxCallBack, NULL);
            return;
          }
          // else handle normally
        }

        // remember the item type currently in the item pointer
        usItemPrevInItemPointer = gpItemPointer.value.usItem;

        if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
          // If it's just been purchased or repaired, mark it as a "new item"
          fNewItem = (gMoveingItem.uiFlags & (ARMS_INV_JUST_PURCHASED | ARMS_INV_ITEM_REPAIRED));
        }

        // try to place the item in the cursor into this inventory slot
        if (UIHandleItemPlacement(uiHandPos, usOldItemIndex, usNewItemIndex, fDeductPoints)) {
          // it worked!  if we're in the SKI...
          if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
            SetNewItem(gpSMCurrentMerc, uiHandPos, fNewItem);

            // and the cursor is now empty
            if (gpItemPointer == NULL) {
              // clean up
              memset(addressof(gMoveingItem), 0, sizeof(INVENTORY_IN_SLOT));
              SetSkiCursor(CURSOR_NORMAL);
            } else {
              // if we're holding something else in the pointer now
              if (usItemPrevInItemPointer != gpItemPointer.value.usItem) {
                // pick up item swapped out of inventory slot into cursor (don't try to sell)
                BeginSkiItemPointer(PLAYERS_INVENTORY, -1, FALSE);
              } else {
                // otherwise, leave the cursor as is, means more items were picked up at once than can be placed in this slot
                // we deal with this by leaving the remainder in the cursor, to be put down elsewhere using subsequent clicks
              }
            }
          }

          // Setup a timer....
          // guiMouseOverItemTime = GetJA2Clock( );
          // gfCheckForMouseOverItem = TRUE;
          // gbCheckForMouseOverItemPos = (INT8)uiHandPos;
        }

        /*
        // Try to place here
        if ( PlaceObject( gpSMCurrentMerc, (UINT8)uiHandPos, gpItemPointer ) )
        {

                if ( fDeductPoints )
                {
                        // Deduct points
                        if ( gpItemPointerSoldier->bLife >= CONSCIOUSNESS )
                        {
                                DeductPoints( gpItemPointerSoldier,  2, 0 );
                        }
                        if ( gpSMCurrentMerc->bLife >= CONSCIOUSNESS )
                        {
                                DeductPoints( gpSMCurrentMerc,  2, 0 );
                        }
                }

                HandleTacticalEffectsOfEquipmentChange( gpSMCurrentMerc, uiHandPos, usOldItemIndex, usNewItemIndex );

                // Dirty
                fInterfacePanelDirty = DIRTYLEVEL2;

                // Check if it's the same now!
                if ( gpItemPointer->ubNumberOfObjects == 0 )
                {
                        EndItemPointer( );
                }

                // Setup a timer....
                guiMouseOverItemTime = GetJA2Clock( );
                gfCheckForMouseOverItem = TRUE;
                gbCheckForMouseOverItemPos = (INT8)uiHandPos;

        }
        */
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    fRightDown = TRUE;
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_UP && fRightDown) {
    fRightDown = FALSE;

    // Return if empty
    if (gpSMCurrentMerc.value.inv[uiHandPos].usItem == NOTHING)
      return;

    // CJC: OK, get source, dest guy if different, don't allow panels to be brought up
    /*
    if ( gpItemPointer && gpSMCurrentMerc->ubID != gpItemPointerSoldier->ubID )
    {
            return;
    }
    */

    // Turn off new item glow!
    gpSMCurrentMerc.value.bNewItemCount[uiHandPos] = 0;

    // Some global stuff here - for esc, etc
    // Check for # of slots in item
    if ((gpSMCurrentMerc.value.inv[uiHandPos].ubNumberOfObjects > 1 && ItemSlotLimit(gpSMCurrentMerc.value.inv[uiHandPos].usItem, uiHandPos) > 0) && (guiCurrentScreen != MAP_SCREEN)) {
      if (!InItemStackPopup()) {
        // InitItemStackPopup( gpSMCurrentMerc, (UINT8)uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, SM_ITEMDESC_WIDTH, SM_ITEMDESC_HEIGHT );
        InitItemStackPopup(gpSMCurrentMerc, uiHandPos, 216, INV_INTERFACE_START_Y, 314, (480 - INV_INTERFACE_START_Y));
      }
    } else {
      if (!InItemDescriptionBox()) {
        InitItemDescriptionBox(gpSMCurrentMerc, uiHandPos, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    fRightDown = FALSE;
    fLeftDown = FALSE;
  }
}

function MergeMessageBoxCallBack(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    AttachObject(gpItemPointerSoldier, addressof(gpSMCurrentMerc.value.inv[gubHandPos]), gpItemPointer);

    // re-evaluate repairs
    gfReEvaluateEveryonesNothingToDo = TRUE;

    if (gpItemPointer.value.usItem == NOTHING) {
      // merge item consumed
      EndItemPointer();
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  } else {
    UIHandleItemPlacement(gubHandPos, gusOldItemIndex, gusNewItemIndex, gfDeductPoints);
  }
}

function HandleMouseOverSoldierFaceForContMove(pSoldier: Pointer<SOLDIERTYPE>, fOn: BOOLEAN): void {
  let pFace: Pointer<FACETYPE>;
  let sGridNo: INT16;

  if (pSoldier == NULL) {
    return;
  }

  if (fOn) {
    // Check if we are waiting to continue move...
    if (CheckForMercContMove(pSoldier)) {
      // Display 'cont' on face....
      // Get face
      pFace = addressof(gFacesData[pSoldier.value.iFaceIndex]);

      pFace.value.fDisplayTextOver = FACE_DRAW_TEXT_OVER;
      wcscpy(pFace.value.zDisplayText, TacticalStr[CONTINUE_OVER_FACE_STR]);

      sGridNo = pSoldier.value.sFinalDestination;

      if (pSoldier.value.bGoodContPath) {
        sGridNo = pSoldier.value.sContPathLocation;
      }

      // While our mouse is here, draw a path!
      PlotPath(pSoldier, sGridNo, NO_COPYROUTE, PLOT, TEMPORARY, pSoldier.value.usUIMovementMode, NOT_STEALTH, FORWARD, pSoldier.value.bActionPoints);
    }
  } else {
    // Remove 'cont' on face....
    // Get face
    pFace = addressof(gFacesData[pSoldier.value.iFaceIndex]);

    pFace.value.fDisplayTextOver = FACE_ERASE_TEXT_OVER;

    // Erase path!
    ErasePath(TRUE);
  }

  fInterfacePanelDirty = DIRTYLEVEL2;
}

function SelectedMercButtonMoveCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  if (gpSMCurrentMerc == NULL) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_MOVE) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, TRUE);
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    HandleMouseOverSoldierFaceForContMove(gpSMCurrentMerc, FALSE);
  }
}

function SelectedMercButtonCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let pVehicle: Pointer<SOLDIERTYPE>;

  if (gpSMCurrentMerc == NULL) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // ATE: Don't if this guy can't....
    if (!gfSMDisableForItems) {
      if (gpSMCurrentMerc.value.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
        pVehicle = GetSoldierStructureForVehicle(gpSMCurrentMerc.value.iVehicleId);

        HandleLocateSelectMerc(pVehicle.value.ubID, 0);
      } else {
        if (CheckForMercContMove(gpSMCurrentMerc)) {
          // Continue
          ContinueMercMovement(gpSMCurrentMerc);
          ErasePath(TRUE);
        } else {
          HandleLocateSelectMerc(gpSMCurrentMerc.value.ubID, 0);
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    // ATE: Cannot get out by right clicking...
    // if ( gpItemPointer == NULL )
    {
      // if ( !gfSMDisableForItems || ( gfSMDisableForItems && gpItemPointer == NULL ) )
      {
        // Delete desc
        if (InItemDescriptionBox()) {
          DeleteItemDescriptionBox();
        }

        gfSwitchPanel = TRUE;
        gbNewPanel = TEAM_PANEL;
      }
    }
  }
}

function SelectedMercEnemyIndicatorCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  if (gpSMCurrentMerc == NULL) {
    return;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // ATE: Don't if this guy can't....
    if (!gfSMDisableForItems) {
      if (gpSMCurrentMerc.value.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
      } else {
        if (gpSMCurrentMerc.value.bOppCnt > 0) {
          CycleVisibleEnemies(gpSMCurrentMerc);
        } else {
          SelectedMercButtonCallback(pRegion, iReason);
        }
      }
    }
  }
}

function BtnStanceUpCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  let bNewStance: INT8;

  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    bNewStance = gAnimControl[gpSMCurrentMerc.value.usAnimState].ubEndHeight;

    if (bNewStance == ANIM_CROUCH) {
      bNewStance = ANIM_STAND;
    } else if (bNewStance == ANIM_PRONE) {
      bNewStance = ANIM_CROUCH;
    }

    UIHandleSoldierStanceChange(gpSMCurrentMerc.value.ubID, bNewStance);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnUpdownCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    // gsInterfaceLevel = gpSMCurrentMerc->bUIInterfaceLevel;

    // Change interface level via HandleUI handler
    UIHandleChangeLevel(NULL);

    // Remember soldier's new value
    gpSMCurrentMerc.value.bUIInterfaceLevel = gsInterfaceLevel;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnClimbCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  let fNearHeigherLevel: BOOLEAN;
  let fNearLowerLevel: BOOLEAN;
  let bDirection: INT8;

  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    GetMercClimbDirection(gpSMCurrentMerc.value.ubID, addressof(fNearLowerLevel), addressof(fNearHeigherLevel));

    if (fNearLowerLevel) {
      BeginSoldierClimbDownRoof(gpSMCurrentMerc);
    }
    if (fNearHeigherLevel) {
      BeginSoldierClimbUpRoof(gpSMCurrentMerc);
    }

    if (FindFenceJumpDirection(gpSMCurrentMerc, gpSMCurrentMerc.value.sGridNo, gpSMCurrentMerc.value.bDirection, addressof(bDirection))) {
      BeginSoldierClimbFence(gpSMCurrentMerc);
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnStanceDownCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  let bNewStance: INT8;

  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    bNewStance = gAnimControl[gpSMCurrentMerc.value.usAnimState].ubEndHeight;

    if (bNewStance == ANIM_STAND) {
      bNewStance = ANIM_CROUCH;
    } else if (bNewStance == ANIM_CROUCH) {
      bNewStance = ANIM_PRONE;
    }

    UIHandleSoldierStanceChange(gpSMCurrentMerc.value.ubID, bNewStance);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnStealthModeCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    gpSMCurrentMerc.value.bStealthMode = !gpSMCurrentMerc.value.bStealthMode;
    gfUIStanceDifferent = TRUE;
    gfPlotNewMovement = TRUE;
    fInterfacePanelDirty = DIRTYLEVEL2;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnHandCursorCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ToggleHandCursorMode(addressof(guiCurrentEvent));
  }
}

function BtnTalkCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ToggleTalkCursorMode(addressof(guiCurrentEvent));
  }
}

function BtnMuteCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (gpSMCurrentMerc.value.uiStatusFlags & SOLDIER_MUTE) {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, TacticalStr[MUTE_OFF_STR], gpSMCurrentMerc.value.name);
      gpSMCurrentMerc.value.uiStatusFlags &= (~SOLDIER_MUTE);
    } else {
      ScreenMsg(FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, TacticalStr[MUTE_ON_STR], gpSMCurrentMerc.value.name);
      gpSMCurrentMerc.value.uiStatusFlags |= (SOLDIER_MUTE);
    }
  }
}

function BtnPrevMercCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  let sID: INT16;

  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    sID = FindPrevActiveAndAliveMerc(gpSMCurrentMerc, TRUE, TRUE);

    gubSelectSMPanelToMerc = sID;

    if (!gfInItemPickupMenu) {
      // if we are in the shop keeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        LocateSoldier(sID, DONTSETLOCATOR);
        // refresh background for player slots (in case item values change due to Flo's discount)
        gubSkiDirtyLevel = SKI_DIRTY_LEVEL2;
      } else
        LocateSoldier(sID, SETLOCATOR);
    }

    // if the user is in the shop keeper interface and is in the item desc
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      if (InItemDescriptionBox()) {
        DeleteItemDescriptionBox();
      }
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnNextMercCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  let sID: INT16;

  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    sID = FindNextActiveAndAliveMerc(gpSMCurrentMerc, TRUE, TRUE);

    // Give him the panel!
    gubSelectSMPanelToMerc = sID;

    if (!gfInItemPickupMenu) {
      // if we are in the shop keeper interface
      if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
        LocateSoldier(sID, DONTSETLOCATOR);
        // refresh background for player slots (in case item values change due to Flo's discount)
        gubSkiDirtyLevel = SKI_DIRTY_LEVEL2;
      } else
        LocateSoldier(sID, SETLOCATOR);
    }

    // if the user is in the shop keeper interface and is in the item desc
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      if (InItemDescriptionBox()) {
        DeleteItemDescriptionBox();
      }
    }
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnOptionsCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    guiPreviousOptionScreen = guiCurrentScreen;
    LeaveTacticalScreen(OPTIONS_SCREEN);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnSMDoneCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    gfBeginEndTurn = TRUE;
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnMapScreenCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    // Enter mapscreen...
    // gfEnteringMapScreen = TRUE;
    GoToMapScreenFromTactical();
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

/*
uiTempVObject[0] = LoadButtonImage( "Interface\\InventoryButtons.sti", -1, 7, -1, -1, -1 );
uiTempVObject[1] = UseLoadedButtonImage( uiTempVObject[0], -1, 17, -1, -1, -1 );
uiTempVObject[2] = UseLoadedButtonImage( uiTempVObject[0], -1, 26, -1, -1, -1 );
iButtonID = QuickCreateButton( uiTempVObject[0], 0, 0, BUTTON_NO_TOGGLE, MSYS_PRIORITY_HIGH, MSYS_NO_CALLBACK, CycleCallback );

void CycleCallback( GUI_BUTTON *btn, INT32 reason )
{
        static INT32 buttonValue = 0;
        if( reason & MSYS_CALLBACK_REASON_LBUTTON_UP )
        {
                buttonValue += buttonValue < 2 ? 1 : -2;
                btn->ImageNum = uiTempVObject[ buttonValue ];
                btn->uiFlags |= BUTTON_DIRTY;
        }
}
*/

function BtnBurstModeCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (!(btn.value.uiFlags & BUTTON_ENABLED))
    return;

  if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    ChangeWeaponMode(gpSMCurrentMerc);
    //		btn->ImageNum = iBurstButtonImages[ gpSMCurrentMerc->bWeaponMode ];
    //		btn->uiFlags |= BUTTON_DIRTY;
  }
}

function BtnLookCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    ToggleLookCursorMode(NULL);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnPositionShowCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
}

// TEAM PANEL!!!!!!!!!!!!!!
function InitializeTEAMPanel(): BOOLEAN {
  let vs_desc: VSURFACE_DESC;
  let VObjectDesc: VOBJECT_DESC;
  let cnt: UINT32;
  let posIndex: UINT32;
  /* static */ let fFirstTime: BOOLEAN = TRUE;

  // INit viewport region
  // Set global mouse regions
  // Define region for viewport
  MSYS_DefineRegion(addressof(gViewportRegion), 0, 0, gsVIEWPORT_END_X, gsVIEWPORT_END_Y, MSYS_PRIORITY_NORMAL, VIDEO_NO_CURSOR, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(addressof(gViewportRegion));

  // Load interface panels
  vs_desc.fCreateFlags = VSURFACE_CREATE_FROMFILE | VSURFACE_SYSTEM_MEM_USAGE;

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\bottom_bar.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiTEAMPanel)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\gold_front.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiTEAMObjects)));

  VObjectDesc.fCreateFlags = VOBJECT_CREATE_FROMFILE;
  FilenameForBPP("INTERFACE\\Bars.sti", VObjectDesc.ImageFile);
  CHECKF(AddVideoObject(addressof(VObjectDesc), addressof(guiBrownBackgroundForTeamPanel)));

  // Clear inv display stuff
  memset(gfTEAM_HandInvDispText, 0, sizeof(gfTEAM_HandInvDispText));

  // Create buttons
  CHECKF(CreateTEAMPanelButtons());

  // Set viewports
  // Define region for panel
  MSYS_DefineRegion(addressof(gTEAM_PanelRegion), 0, gsVIEWPORT_END_Y, 640, 480, MSYS_PRIORITY_NORMAL, CURSOR_NORMAL, MSYS_NO_CALLBACK, MSYS_NO_CALLBACK);
  // Add region
  MSYS_AddRegion(addressof(gTEAM_PanelRegion));

  for (posIndex = 0, cnt = 0; cnt < 6; cnt++, posIndex += 2) {
    MSYS_DefineRegion(addressof(gTEAM_FaceRegions[cnt]), sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], (sTEAMFacesXY[posIndex] + TM_FACE_WIDTH), (sTEAMFacesXY[posIndex + 1] + TM_FACE_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MercFacePanelMoveCallback, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_FaceRegions[cnt]));
    MSYS_SetRegionUserData(addressof(gTEAM_FaceRegions[cnt]), 0, cnt);

    MSYS_DefineRegion(addressof(gTEAM_EnemyIndicator[cnt]), (sTEAMFacesXY[posIndex] + 1), (sTEAMFacesXY[posIndex + 1] + 1), (sTEAMFacesXY[posIndex] + INDICATOR_BOX_WIDTH), (sTEAMFacesXY[posIndex + 1] + INDICATOR_BOX_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, EnemyIndicatorClickCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_EnemyIndicator[cnt]));
    MSYS_SetRegionUserData(addressof(gTEAM_EnemyIndicator[cnt]), 0, cnt);

    if (IsMouseInRegion(addressof(gTEAM_FaceRegions[cnt]))) {
      if (gTeamPanel[cnt].ubID != NOBODY) {
        HandleMouseOverSoldierFaceForContMove(MercPtrs[gTeamPanel[cnt].ubID], TRUE);
      }
    }

    MSYS_DefineRegion(addressof(gTEAM_BarsRegions[cnt]), sTEAMBarsXY[posIndex], sTEAMBarsXY[posIndex + 1], (sTEAMBarsXY[posIndex] + TM_BARS_REGION_WIDTH), (sTEAMBarsXY[posIndex + 1] + TM_BARS_REGION_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_BarsRegions[cnt]));
    MSYS_SetRegionUserData(addressof(gTEAM_BarsRegions[cnt]), 0, cnt);

    MSYS_DefineRegion(addressof(gTEAM_LeftBarsRegions[cnt]), (sTEAMFacesXY[posIndex] - 8), sTEAMFacesXY[posIndex + 1], (sTEAMFacesXY[posIndex]), (sTEAMFacesXY[posIndex + 1] + TM_BARS_REGION_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, MercFacePanelCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_LeftBarsRegions[cnt]));
    MSYS_SetRegionUserData(addressof(gTEAM_LeftBarsRegions[cnt]), 0, cnt);

    MSYS_DefineRegion(addressof(gTEAM_FirstHandInv[cnt]), sTEAMHandInvXY[posIndex], sTEAMHandInvXY[posIndex + 1], (sTEAMHandInvXY[posIndex] + TM_INV_WIDTH), (sTEAMHandInvXY[posIndex + 1] + TM_INV_HEIGHT), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, TMClickFirstHandInvCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_FirstHandInv[cnt]));

    // Add user data
    MSYS_SetRegionUserData(addressof(gTEAM_FirstHandInv[cnt]), 0, cnt);

    MSYS_DefineRegion(addressof(gTEAM_SecondHandInv[cnt]), sTEAMHandInvXY[posIndex], (sTEAMHandInvXY[posIndex + 1] + 24), (sTEAMHandInvXY[posIndex] + TM_INV_WIDTH), (sTEAMHandInvXY[posIndex + 1] + TM_INV_HEIGHT + 24), MSYS_PRIORITY_NORMAL, MSYS_NO_CURSOR, MSYS_NO_CALLBACK, TMClickSecondHandInvCallback);
    // Add region
    MSYS_AddRegion(addressof(gTEAM_SecondHandInv[cnt]));

    // Add user data
    MSYS_SetRegionUserData(addressof(gTEAM_SecondHandInv[cnt]), 0, cnt);
  }

  // DEfine region for selected guy panel
  // MSYS_DefineRegion( &gSM_SELMERCPanalRegion, SM_SELMERC_FACE_X, SM_SELMERC_FACE_Y, SM_SELMERC_FACE_X + SM_SELMERC_FACE_WIDTH, SM_SELMERC_FACE_Y + SM_SELMERC_FACE_HEIGHT, MSYS_PRIORITY_NORMAL,
  //					 CURSOR_NORMAL, MSYS_NO_CALLBACK, SelectedMercButtonCallback );
  // Add region
  // MSYS_AddRegion( &gSM_SELMERCPanalRegion );

  return TRUE;
}

function ShutdownTEAMPanel(): BOOLEAN {
  let cnt: UINT32;

  // All buttons and regions and video objects and video surfaces will be deleted at shutddown of SGM
  // We may want to delete them at the interm as well, to free up room for other panels
  // Delete video objects!
  DeleteVideoObjectFromIndex(guiTEAMPanel);
  DeleteVideoObjectFromIndex(guiTEAMObjects);
  DeleteVideoObjectFromIndex(guiBrownBackgroundForTeamPanel);

  MSYS_RemoveRegion(addressof(gTEAM_PanelRegion));

  // Remove viewport
  MSYS_RemoveRegion(addressof(gViewportRegion));

  for (cnt = 0; cnt < 6; cnt++) {
    MSYS_RemoveRegion(addressof(gTEAM_EnemyIndicator[cnt]));
    MSYS_RemoveRegion(addressof(gTEAM_FaceRegions[cnt]));
    MSYS_RemoveRegion(addressof(gTEAM_BarsRegions[cnt]));
    MSYS_RemoveRegion(addressof(gTEAM_LeftBarsRegions[cnt]));
    MSYS_RemoveRegion(addressof(gTEAM_FirstHandInv[cnt]));
    MSYS_RemoveRegion(addressof(gTEAM_SecondHandInv[cnt]));

    if (gTeamPanel[cnt].ubID != NOBODY) {
      HandleMouseOverSoldierFaceForContMove(MercPtrs[gTeamPanel[cnt].ubID], FALSE);
    }
  }

  // Remove buttons
  RemoveTEAMPanelButtons();

  // turn off the display of the squad list
  if (fRenderRadarScreen == FALSE) {
    // start rendering radar region again,
    fRenderRadarScreen = TRUE;

    // remove squad panel
    // CreateDestroyMouseRegionsForSquadList( );
  }
  return TRUE;
}

function RenderTEAMPanel(fDirty: BOOLEAN): void {
  let sFontX: INT16;
  let sFontY: INT16;
  let cnt: UINT32;
  let posIndex: UINT32;
  let pSoldier: Pointer<SOLDIERTYPE>;
  /* static */ let pStr: INT16[] /* [200] */;
  /* static */ let pMoraleStr: INT16[] /* [20] */;

  if (fDirty == DIRTYLEVEL2) {
    MarkAButtonDirty(iTEAMPanelButtons[TEAM_DONE_BUTTON]);
    MarkAButtonDirty(iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON]);
    MarkAButtonDirty(iTEAMPanelButtons[CHANGE_SQUAD_BUTTON]);

    // Blit video surface
    // if(gbPixelDepth==16)
    //{
    BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMPanel, 0, INTERFACE_START_X, INTERFACE_START_Y, VO_BLT_SRCTRANSPARENCY, NULL);
    //}
    RestoreExternBackgroundRect(INTERFACE_START_X, INTERFACE_START_Y, (640 - INTERFACE_START_X), (480 - INTERFACE_START_Y));

    // LOOP THROUGH ALL MERCS ON TEAM PANEL
    for (cnt = 0, posIndex = 0; cnt < NUM_TEAM_SLOTS; cnt++, posIndex += 2) {
      // GET SOLDIER
      if (!gTeamPanel[cnt].fOccupied) {
        // BLIT CLOSE PANEL
        BltVideoObjectFromIndex(guiSAVEBUFFER, guiCLOSE, 5, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, NULL);
        RestoreExternBackgroundRect(sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], TM_FACE_WIDTH, TM_FACE_HEIGHT);

        // BLIT AP CLOSE PANEL
        // BltVideoObjectFromIndex( FRAME_BUFFER, guiTEAMObjects, 3, sTEAMAPPanelXY[ posIndex ], sTEAMAPPanelXY[ posIndex + 1 ], VO_BLT_SRCTRANSPARENCY, NULL );
        // RestoreExternBackgroundRect( (INT16)(sTEAMAPPanelXY[ posIndex ]), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ]), TM_APPANEL_WIDTH, TM_APPANEL_HEIGHT );
        // InvalidateRegion( (INT16)(sTEAMAPPanelXY[ posIndex ]), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ]), (INT16)(sTEAMAPPanelXY[ posIndex ] + TM_APPANEL_WIDTH), (INT16)(sTEAMAPPanelXY[ posIndex + 1 ] + TM_APPANEL_HEIGHT ) );

        if (gTacticalStatus.ubCurrentTeam != OUR_TEAM || INTERRUPT_QUEUED) {
          // Hatch out...
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, NULL);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);
        }
      } else {
        pSoldier = MercPtrs[gTeamPanel[cnt].ubID];

        if (pSoldier.value.uiStatusFlags & (SOLDIER_DRIVER)) {
          // Get soldier pointer for vehicle.....
          let pVehicle: Pointer<SOLDIERTYPE>;

          pVehicle = GetSoldierStructureForVehicle(pSoldier.value.iVehicleId);

          // OK, for each item, set dirty text if applicable!
          swprintf(pStr, TacticalStr[DRIVER_POPUPTEXT], pVehicle.value.bLife, pVehicle.value.bLifeMax, pVehicle.value.bBreath, pVehicle.value.bBreathMax);
          SetRegionFastHelpText(addressof(gTEAM_FirstHandInv[cnt]), pStr);
        }
        // Add text for first hand popup
        else {
          GetHelpTextForItem(pStr, addressof(pSoldier.value.inv[HANDPOS]), pSoldier);

          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(addressof(gTEAM_FirstHandInv[cnt]), pStr);
        }

        // Add text for seonc hand popup
        if (pSoldier.value.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(addressof(gTEAM_SecondHandInv[cnt]), TacticalStr[EXIT_VEHICLE_POPUPTEXT]);
        } else {
          GetHelpTextForItem(pStr, addressof(pSoldier.value.inv[SECONDHANDPOS]), pSoldier);

          // OK, for each item, set dirty text if applicable!
          SetRegionFastHelpText(addressof(gTEAM_SecondHandInv[cnt]), pStr);
        }

        // Render Selected guy if selected
        if (gusSelectedSoldier == pSoldier.value.ubID && gTacticalStatus.ubCurrentTeam == OUR_TEAM && OK_INTERRUPT_MERC(pSoldier)) {
          // if(gbPixelDepth==16)
          //{
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 0, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, NULL);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);

          // Render faceplate
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X, sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y, VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( (INT16)(sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X), (INT16)(sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y ), TM_FACEPLATE_WIDTH, TM_FACEPLATE_HEIGHT );
          //}
        } else if (gTacticalStatus.ubCurrentTeam != OUR_TEAM || !OK_INTERRUPT_MERC(pSoldier)) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], VO_BLT_SRCTRANSPARENCY, NULL);
          RestoreExternBackgroundRect(sTEAMFaceHighlXY[posIndex], sTEAMFaceHighlXY[posIndex + 1], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT);
          // Render non-selection
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 4, sTEAMFaceHighlXY[ posIndex ], sTEAMFaceHighlXY[ posIndex + 1 ], VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( sTEAMFaceHighlXY[ posIndex ], sTEAMFaceHighlXY[ posIndex + 1 ], TM_FACEHIGHTL_WIDTH, TM_FACEHIGHTL_HEIGHT );

          // Render faceplate
          // BltVideoObjectFromIndex( guiSAVEBUFFER, guiTEAMObjects, 1, sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X, sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y, VO_BLT_SRCTRANSPARENCY, NULL );
          // RestoreExternBackgroundRect( (INT16)(sTEAMFacesXY[ posIndex ] + TM_FACEPLATE_OFFSET_X), (INT16)(sTEAMFacesXY[ posIndex + 1 ] + TM_FACEPLATE_OFFSET_Y ), TM_FACEPLATE_WIDTH, TM_FACEPLATE_HEIGHT );
        }

        CheckForFacePanelStartAnims(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1]);

        RenderSoldierFace(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1], TRUE);

        // Restore AP/LIFE POSIITONS

        // Render name!
        SetFont(BLOCKFONT2);

        if (pSoldier.value.bStealthMode) {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_LTYELLOW);
        } else {
          SetFontBackground(FONT_MCOLOR_BLACK);
          SetFontForeground(FONT_MCOLOR_LTGRAY);
        }

        // RENDER ON SAVE BUFFER!
        SetFontDestBuffer(guiSAVEBUFFER, 0, 0, 640, 480, FALSE);
        VarFindFontCenterCoordinates((sTEAMNamesXY[posIndex] + 2), (sTEAMNamesXY[posIndex + 1]), TM_NAME_WIDTH, TM_NAME_HEIGHT, BLOCKFONT2, addressof(sFontX), addressof(sFontY), "%s", pSoldier.value.name);
        mprintf(sFontX, sFontY, "%s", pSoldier.value.name);
        gprintfRestore(sFontX, sFontY, "%s", pSoldier.value.name);
        // reset to frame buffer!
        SetFontDestBuffer(FRAME_BUFFER, 0, 0, 640, 480, FALSE);
      }
    }

    RenderTownIDString();
  }

  // Loop through all mercs and make go
  for (cnt = 0, posIndex = 0; cnt < NUM_TEAM_SLOTS; cnt++, posIndex += 2) {
    // GET SOLDIER
    if (gTeamPanel[cnt].fOccupied) {
      pSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      // Update animations....
      if (pSoldier.value.fClosePanel || pSoldier.value.fClosePanelToDie) {
        pSoldier.value.sPanelFaceX = gFacesData[pSoldier.value.iFaceIndex].usFaceX;
        pSoldier.value.sPanelFaceY = gFacesData[pSoldier.value.iFaceIndex].usFaceY;
      }

      if (fDirty != DIRTYLEVEL0) {
        // UPdate stats!
        if (fDirty == DIRTYLEVEL2) {
          if (pSoldier.value.bLife != 0) {
            if (pSoldier.value.uiStatusFlags & SOLDIER_VEHICLE) {
              swprintf(pStr, TacticalStr[VEHICLE_VITAL_STATS_POPUPTEXT], pSoldier.value.bLife, pSoldier.value.bLifeMax, pSoldier.value.bBreath, pSoldier.value.bBreathMax);
              SetRegionFastHelpText(addressof(gTEAM_BarsRegions[cnt]), pStr);
            } else if (pSoldier.value.uiStatusFlags & SOLDIER_ROBOT) {
              swprintf(pStr, gzLateLocalizedString[16], pSoldier.value.bLife, pSoldier.value.bLifeMax);
              SetRegionFastHelpText(addressof(gTEAM_BarsRegions[cnt]), pStr);
            } else {
              GetMoraleString(pSoldier, pMoraleStr);
              swprintf(pStr, TacticalStr[MERC_VITAL_STATS_POPUPTEXT], pSoldier.value.bLife, pSoldier.value.bLifeMax, pSoldier.value.bBreath, pSoldier.value.bBreathMax, pMoraleStr);
              SetRegionFastHelpText(addressof(gTEAM_BarsRegions[cnt]), pStr);
            }
          } else {
            SetRegionFastHelpText(addressof(gTEAM_BarsRegions[cnt]), "");
          }
        }

        if (!(pSoldier.value.uiStatusFlags & SOLDIER_DEAD)) {
          DrawLifeUIBarEx(pSoldier, sTEAMLifeXY[posIndex], sTEAMLifeXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, TRUE, FRAME_BUFFER);

          if (!(pSoldier.value.uiStatusFlags & SOLDIER_ROBOT)) {
            DrawBreathUIBarEx(pSoldier, sTEAMBreathXY[posIndex], sTEAMBreathXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, TRUE, FRAME_BUFFER);
            DrawMoraleUIBarEx(pSoldier, sTEAMMoraleXY[posIndex], sTEAMMoraleXY[posIndex + 1], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, TRUE, FRAME_BUFFER);
          }

          if (gTacticalStatus.uiFlags & TURNBASED && pSoldier.value.bLife >= OKLIFE) {
            // Render APs
            SetFont(TINYFONT1);

            // if ( pSoldier->sLastTarget != NOWHERE && !EnoughPoints( pSoldier, MinAPsToAttack( pSoldier, pSoldier->sLastTarget, TRUE ), 0, FALSE ) || GetUIApsToDisplay( pSoldier ) < 0 )
            if (!EnoughPoints(pSoldier, MinAPsToAttack(pSoldier, pSoldier.value.sLastTarget, TRUE), 0, FALSE) || GetUIApsToDisplay(pSoldier) < 0) {
              SetFontBackground(FONT_MCOLOR_BLACK);
              SetFontForeground(FONT_MCOLOR_DKRED);
            } else {
              if (MercUnderTheInfluence(pSoldier)) {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTBLUE);
              } else if (pSoldier.value.bStealthMode) {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTYELLOW);
              } else {
                SetFontBackground(FONT_MCOLOR_BLACK);
                SetFontForeground(FONT_MCOLOR_LTGRAY);
              }
            }
            RestoreExternBackgroundRect(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT);

            if (gTacticalStatus.uiFlags & INCOMBAT) {
              VarFindFontCenterCoordinates(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT, TINYFONT1, addressof(sFontX), addressof(sFontY), "%d", GetUIApsToDisplay(pSoldier));
              mprintf(sFontX, sTEAMApXY[posIndex + 1], "%d", GetUIApsToDisplay(pSoldier));
            }
          }
        } else {
          // Erase!
          // DrawUIBar( pSoldier->bBreath, sTEAMBreathXY[ posIndex ], sTEAMBreathXY[ posIndex + 1 ], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, DRAW_ERASE_BAR );
          // DrawUIBar( pSoldier->bLife, sTEAMLifeXY[ posIndex ], sTEAMLifeXY[ posIndex + 1 ], TM_LIFEBAR_WIDTH, TM_LIFEBAR_HEIGHT, DRAW_ERASE_BAR );

          // Erase APs
          RestoreExternBackgroundRect(sTEAMApXY[posIndex], sTEAMApXY[posIndex + 1], TM_AP_WIDTH, TM_AP_HEIGHT);
        }
      }

      RenderSoldierTeamInv(pSoldier, sTEAMHandInvXY[posIndex], sTEAMHandInvXY[posIndex + 1], cnt, fDirty);

      HandleSoldierFaceFlash(pSoldier, sTEAMFacesXY[posIndex], sTEAMFacesXY[posIndex + 1]);

      if (!(guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
        // HandlePanelFaceAnimations( pSoldier );
      }
    }
  }
  UpdateTEAMPanel();

  if (fRenderRadarScreen == TRUE) {
    // Render clock
    // RenderClock( CLOCK_X, CLOCK_Y );
    CreateMouseRegionForPauseOfClock(CLOCK_REGION_START_X, CLOCK_REGION_START_Y);
  } else {
    RemoveMouseRegionForPauseOfClock();
  }
}

function CreateTEAMPanelButtons(): BOOLEAN {
  let ubString: UINT8[] /* [48] */;

  FilenameForBPP("INTERFACE\\bottom_bar_buttons.sti", ubString);

  // Load button Graphics
  iTEAMPanelImages[ENDTURN_IMAGES] = LoadButtonImage(ubString, -1, 0, -1, 3, -1);
  iTEAMPanelImages[ROSTERMODE_IMAGES] = UseLoadedButtonImage(iTEAMPanelImages[ENDTURN_IMAGES], -1, 1, -1, 4, -1);
  iTEAMPanelImages[DISK_IMAGES] = UseLoadedButtonImage(iTEAMPanelImages[ENDTURN_IMAGES], -1, 2, -1, 5, -1);

  // Create buttons
  iTEAMPanelButtons[TEAM_DONE_BUTTON] = QuickCreateButton(iTEAMPanelImages[ENDTURN_IMAGES], TM_ENDTURN_X, TM_ENDTURN_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnEndTurnCallback);
  if (iTEAMPanelButtons[TEAM_DONE_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[TEAM_DONE_BUTTON], TacticalStr[END_TURN_POPUPTEXT]);

  iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON] = QuickCreateButton(iTEAMPanelImages[ROSTERMODE_IMAGES], TM_ROSTERMODE_X, TM_ROSTERMODE_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnRostermodeCallback);
  if (iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON], TacticalStr[MAPSCREEN_POPUPTEXT]);

  iTEAMPanelButtons[CHANGE_SQUAD_BUTTON] = QuickCreateButton(iTEAMPanelImages[DISK_IMAGES], TM_DISK_X, TM_DISK_Y, BUTTON_TOGGLE, MSYS_PRIORITY_HIGH - 1, DEFAULT_MOVE_CALLBACK, BtnSquadCallback);
  if (iTEAMPanelButtons[CHANGE_SQUAD_BUTTON] == -1) {
    DebugMsg(TOPIC_JA2, DBG_LEVEL_3, "Cannot create Interface button");
    return FALSE;
  }
  SetButtonFastHelpText(iTEAMPanelButtons[CHANGE_SQUAD_BUTTON], TacticalStr[CHANGE_SQUAD_POPUPTEXT]);

  return TRUE;
}

function RemoveTEAMPanelButtons(): void {
  let cnt: UINT32;

  for (cnt = 0; cnt < NUM_TEAM_BUTTONS; cnt++) {
    RemoveButton(iTEAMPanelButtons[cnt]);
  }

  for (cnt = 0; cnt < NUM_TEAM_BUTTON_IMAGES; cnt++) {
    UnloadButtonImage(iTEAMPanelImages[cnt]);
  }
}

function BtnEndTurnCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    // END TURN
    UIHandleEndTurn(NULL);
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function BtnRostermodeCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    if (guiCurrentScreen == GAME_SCREEN) {
      GoToMapScreenFromTactical();
      //			EnableRadarScreenRender( );
    }
  }
}

// callback to handle squad switching callback
function BtnSquadCallback(btn: Pointer<GUI_BUTTON>, reason: INT32): void {
  if (reason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    btn.value.uiFlags |= BUTTON_CLICKED_ON;
  } else if (reason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);

    // ScreenMsg( FONT_MCOLOR_LTYELLOW, MSG_INTERFACE, L"Not Implemented Yet" );
    ToggleRadarScreenRender();
  } else if (reason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    btn.value.uiFlags &= (~BUTTON_CLICKED_ON);
  }
}

function SetTEAMPanelCurrentMerc(ubNewID: UINT8): void {
  // Ignore ther ID given!
  // ALWYAS USE CURRENT MERC!

  fInterfacePanelDirty = DIRTYLEVEL2;

  UpdateTEAMPanel();
}

function UpdateTEAMPanel(): void {
  let cnt: INT32;

  if ((gTacticalStatus.ubCurrentTeam != gbPlayerNum) || (gTacticalStatus.uiFlags & REALTIME) || !(gTacticalStatus.uiFlags & INCOMBAT)) {
    DisableButton(iTEAMPanelButtons[TEAM_DONE_BUTTON]);
  } else {
    EnableButton(iTEAMPanelButtons[TEAM_DONE_BUTTON]);
  }

  if (gTacticalStatus.uiFlags & ENGAGED_IN_CONV) {
    DisableButton(iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON]);
  }

  if (gfDisableTacticalPanelButtons) {
    DisableButton(iTEAMPanelButtons[TEAM_DONE_BUTTON]);
    DisableButton(iTEAMPanelButtons[TEAM_MAP_SCREEN_BUTTON]);
    DisableButton(iTEAMPanelButtons[CHANGE_SQUAD_BUTTON]);

    // OK, disable item regions.......
    for (cnt = 0; cnt < 6; cnt++) {
      MSYS_DisableRegion(addressof(gTEAM_EnemyIndicator[cnt]));

      MSYS_DisableRegion(addressof(gTEAM_FirstHandInv[cnt]));

      MSYS_DisableRegion(addressof(gTEAM_SecondHandInv[cnt]));
    }

    // disable the radar map region
    // If NOT in overhead map
    if (!InOverheadMap()) {
      MSYS_DisableRegion(addressof(gRadarRegion));
    }
  } else {
    EnableButton(iTEAMPanelButtons[CHANGE_SQUAD_BUTTON]);

    for (cnt = 0; cnt < 6; cnt++) {
      MSYS_EnableRegion(addressof(gTEAM_EnemyIndicator[cnt]));

      MSYS_EnableRegion(addressof(gTEAM_FirstHandInv[cnt]));

      MSYS_EnableRegion(addressof(gTEAM_SecondHandInv[cnt]));
    }

    // Enable the radar map region
    MSYS_EnableRegion(addressof(gRadarRegion));
  }
}

function HandleMouseOverTeamFaceForContMove(fOn: BOOLEAN): void {
  let pFace: Pointer<FACETYPE>;

  if (fOn) {
    // Check if we are waiting to continue move...
    if (CheckForMercContMove(gpSMCurrentMerc)) {
      // Display 'cont' on face....
      // Get face
      pFace = addressof(gFacesData[gpSMCurrentMerc.value.iFaceIndex]);

      pFace.value.fDisplayTextOver = FACE_DRAW_TEXT_OVER;
      wcscpy(pFace.value.zDisplayText, TacticalStr[CONTINUE_OVER_FACE_STR]);

      // While our mouse is here, draw a path!
      PlotPath(gpSMCurrentMerc, gpSMCurrentMerc.value.sFinalDestination, NO_COPYROUTE, PLOT, TEMPORARY, gpSMCurrentMerc.value.usUIMovementMode, NOT_STEALTH, FORWARD, gpSMCurrentMerc.value.bActionPoints);
    }
  } else {
    // Remove 'cont' on face....
    // Get face
    pFace = addressof(gFacesData[gpSMCurrentMerc.value.iFaceIndex]);

    pFace.value.fDisplayTextOver = FACE_ERASE_TEXT_OVER;

    // Erase path!
    ErasePath(TRUE);
  }
}

function MercFacePanelMoveCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let pSoldier: Pointer<SOLDIERTYPE>;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  pSoldier = MercPtrs[ubSoldierID];

  if (!pSoldier.value.bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_MOVE) {
    HandleMouseOverSoldierFaceForContMove(pSoldier, TRUE);
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    HandleMouseOverSoldierFaceForContMove(pSoldier, FALSE);
  }
}

function EnemyIndicatorClickCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (!MercPtrs[ubSoldierID].value.bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    if (MercPtrs[ubSoldierID].value.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
    } else {
      let pSoldier: Pointer<SOLDIERTYPE>;

      pSoldier = MercPtrs[ubSoldierID];

      if (pSoldier.value.bOppCnt > 0) {
        // Cycle....
        CycleVisibleEnemies(pSoldier);
      } else {
        MercFacePanelCallback(pRegion, iReason);
      }
    }
  }
}

function MercFacePanelCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let pVehicle: Pointer<SOLDIERTYPE>;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
      SetInfoChar(ubID);
    }
    return;
  }

  if (ubID == NOBODY) {
    return;
  }

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (!MercPtrs[ubSoldierID].value.bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    if (!gfInItemPickupMenu && gpItemPointer == NULL) {
      if (MercPtrs[ubSoldierID].value.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER)) {
        pVehicle = GetSoldierStructureForVehicle(MercPtrs[ubSoldierID].value.iVehicleId);

        HandleLocateSelectMerc(pVehicle.value.ubID, 0);
      } else {
        if (!InOverheadMap()) {
          // If we can continue a move, do so!
          if (CheckForMercContMove(MercPtrs[ubSoldierID])) {
            // Continue
            ContinueMercMovement(MercPtrs[ubSoldierID]);
            ErasePath(TRUE);
          } else {
            HandleLocateSelectMerc(ubSoldierID, 0);
          }
        } else {
          SelectSoldier(ubSoldierID, TRUE, FALSE);
        }
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    if (!InOverheadMap()) {
      // Only if guy is not dead!
      if (!(MercPtrs[ubSoldierID].value.uiStatusFlags & SOLDIER_DEAD) && !AM_AN_EPC(MercPtrs[ubSoldierID]) && !(MercPtrs[ubSoldierID].value.uiStatusFlags & (SOLDIER_DRIVER | SOLDIER_PASSENGER))) {
        gfSwitchPanel = TRUE;
        gbNewPanel = SM_PANEL;
        gubNewPanelParam = ubSoldierID;
      }
    }
  }
}

function HandleLocateSelectMerc(ubID: UINT8, bFlag: INT8): void {
  let fSelect: BOOLEAN = FALSE;

  if (!MercPtrs[ubID].value.bActive) {
    return;
  }

  if (gpItemPointer != NULL) {
    // ATE: Disable for feel purposes....
    // return;
  }

  // ATE: No matter what we do... if below OKLIFE, just locate....
  if (MercPtrs[ubID].value.bLife < OKLIFE) {
    LocateSoldier(ubID, SETLOCATOR);
    return;
  }

  if (_KeyDown(ALT)) {
    if (gGameSettings.fOptions[TOPTION_OLD_SELECTION_METHOD]) {
      // Select merc
      InternalSelectSoldier(ubID, TRUE, FALSE, TRUE);
      MercPtrs[ubID].value.fFlashLocator = FALSE;
      ResetMultiSelection();
    } else {
      // Just locate....
      LocateSoldier(ubID, SETLOCATOR);
    }
  } else {
    if (MercPtrs[ubID].value.fFlashLocator == FALSE) {
      if (gGameSettings.fOptions[TOPTION_OLD_SELECTION_METHOD]) {
        // If we are currently selected, slide to location
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, SETLOCATOR);
        } else {
          LocateSoldier(ubID, SETLOCATOR);
        }
      } else {
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, SETLOCATOR);
        } else {
          fSelect = TRUE;
          // ShowRadioLocator( ubID, SHOW_LOCATOR_NORMAL );
        }
      }
    } else {
      if (gGameSettings.fOptions[TOPTION_OLD_SELECTION_METHOD]) {
        // If we are currently selected, slide to location
        if (ubID == gusSelectedSoldier) {
          SlideTo(NOWHERE, gusSelectedSoldier, NOBODY, DONTSETLOCATOR);
        } else {
          LocateSoldier(ubID, DONTSETLOCATOR);
        }

        fSelect = TRUE;
      } else {
        if (ubID == gusSelectedSoldier) {
          LocateSoldier(ubID, DONTSETLOCATOR);
        } else {
          fSelect = TRUE;
        }
      }
    }

    if (bFlag == LOCATEANDSELECT_MERC) {
      fSelect = TRUE;
    }

    if (fSelect) {
      // Select merc, only if alive!
      if (!(MercPtrs[ubID].value.uiStatusFlags & SOLDIER_DEAD)) {
        InternalSelectSoldier(ubID, TRUE, FALSE, TRUE);
      }
    }
  }

  ResetMultiSelection();

  // Handle locate select merc....
  HandleMouseOverSoldierFaceForContMove(MercPtrs[ubID], TRUE);
}

function ShowRadioLocator(ubID: UINT8, ubLocatorSpeed: UINT8): void {
  RESETTIMECOUNTER(MercPtrs[ubID].value.FlashSelCounter, FLASH_SELECTOR_DELAY);

  // LocateSoldier( ubID, FALSE );	// IC - this is already being done outside of this function :)
  MercPtrs[ubID].value.fFlashLocator = TRUE;
  // gbPanelSelectedGuy = ubID;	IC - had to move this outside to make this function versatile
  MercPtrs[ubID].value.sLocatorFrame = 0;

  if (ubLocatorSpeed == SHOW_LOCATOR_NORMAL) {
    // If we are an AI guy, and we have the baton, make lower...
    // ( MercPtrs[ ubID ]->uiStatusFlags & SOLDIER_UNDERAICONTROL && MercPtrs[ ubID ]->bTeam != gbPlayerNum )
    //
    // ercPtrs[ ubID ]->ubNumLocateCycles = 3;
    //
    // se
    //
    MercPtrs[ubID].value.ubNumLocateCycles = 5;
    //
  } else {
    MercPtrs[ubID].value.ubNumLocateCycles = 3;
  }
}

function EndRadioLocator(ubID: UINT8): void {
  MercPtrs[ubID].value.fFlashLocator = FALSE;
  MercPtrs[ubID].value.fShowLocator = FALSE;
}

function CheckForFacePanelStartAnims(pSoldier: Pointer<SOLDIERTYPE>, sPanelX: INT16, sPanelY: INT16): void {
  if (!pSoldier.value.bActive) {
    return;
  }

  if (pSoldier.value.fUIdeadMerc) {
    //		pSoldier->sPanelFaceX	= sPanelX;
    //		pSoldier->sPanelFaceY	= sPanelY;
  }
}

function FinishAnySkullPanelAnimations(): void {
  let pTeamSoldier: Pointer<SOLDIERTYPE>;
  let cnt2: INT32;

  cnt2 = gTacticalStatus.Team[gbPlayerNum].bFirstID;

  // run through list
  for (pTeamSoldier = MercPtrs[cnt2]; cnt2 <= gTacticalStatus.Team[gbPlayerNum].bLastID; cnt2++, pTeamSoldier++) {
    if (pTeamSoldier.value.bActive && pTeamSoldier.value.bLife == 0) {
      if (pTeamSoldier.value.fUIdeadMerc || pTeamSoldier.value.fClosePanelToDie) {
        HandlePlayerTeamMemberDeathAfterSkullAnimation(pTeamSoldier);

        pTeamSoldier.value.fUIdeadMerc = FALSE;
        pTeamSoldier.value.fClosePanelToDie = FALSE;
      }
    }
  }
}

function HandlePanelFaceAnimations(pSoldier: Pointer<SOLDIERTYPE>): void {
  if (pSoldier.value.bTeam != gbPlayerNum) {
    return;
  }

  if (!pSoldier.value.bActive) {
    return;
  }

  if (pSoldier.value.uiStatusFlags & SOLDIER_VEHICLE) {
    // Don't do this for a vehice.
    return;
  }

  // If this is the first time we are active, open panel!
  if (pSoldier.value.fUInewMerc) {
    pSoldier.value.fUInewMerc = FALSE;
  }

  if (pSoldier.value.fUICloseMerc) {
    pSoldier.value.fUICloseMerc = FALSE;
  }

  if (pSoldier.value.fUIdeadMerc) {
    pSoldier.value.sPanelFaceX = gFacesData[pSoldier.value.iFaceIndex].usFaceX;
    pSoldier.value.sPanelFaceY = gFacesData[pSoldier.value.iFaceIndex].usFaceY;

    pSoldier.value.fUIdeadMerc = FALSE;
    pSoldier.value.fClosePanel = TRUE;
    pSoldier.value.fClosePanelToDie = TRUE;
    pSoldier.value.ubClosePanelFrame = 0;
    pSoldier.value.ubDeadPanelFrame = 0;
    RESETTIMECOUNTER(pSoldier.value.PanelAnimateCounter, 160);
  }

  if (pSoldier.value.fClosePanel) {
    if (TIMECOUNTERDONE(pSoldier.value.PanelAnimateCounter, 160)) {
      pSoldier.value.ubClosePanelFrame++;

      if (pSoldier.value.ubClosePanelFrame > 5) {
        pSoldier.value.fClosePanel = FALSE;
        pSoldier.value.ubClosePanelFrame = 5;

        if (pSoldier.value.fClosePanelToDie) {
          pSoldier.value.fDeadPanel = TRUE;
          // PlayJA2Sample( (UINT8)HEADCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN );
        } else {
          if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
            RestoreExternBackgroundRect(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
          }
        }
      }
      RESETTIMECOUNTER(pSoldier.value.PanelAnimateCounter, 160);
    }
  }

  if (pSoldier.value.fClosePanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
      RestoreExternBackgroundRect(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
      BltVideoObjectFromIndex(FRAME_BUFFER, guiCLOSE, pSoldier.value.ubClosePanelFrame, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);
      InvalidateRegion(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, pSoldier.value.sPanelFaceX + TM_FACE_WIDTH, pSoldier.value.sPanelFaceY + TM_FACE_HEIGHT);
    }
    //}
  }

  if (pSoldier.value.fDeadPanel) {
    if (TIMECOUNTERDONE(pSoldier.value.PanelAnimateCounter, 160)) {
      pSoldier.value.ubDeadPanelFrame++;

      if (pSoldier.value.ubDeadPanelFrame == 4) {
        ScreenMsg(FONT_RED, MSG_SKULL_UI_FEEDBACK, pMercDeadString[0], pSoldier.value.name);

        PlayJA2Sample(DOORCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN);
        PlayJA2Sample(HEADCR_1, RATE_11025, HIGHVOLUME, 1, MIDDLEPAN);
      }

      if (pSoldier.value.ubDeadPanelFrame > 5) {
        pSoldier.value.fDeadPanel = FALSE;
        pSoldier.value.ubDeadPanelFrame = 5;
        pSoldier.value.fClosePanelToDie = FALSE;

        // Finish!
        if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiDEAD, pSoldier.value.ubDeadPanelFrame, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);

          // Blit hatch!
          BltVideoObjectFromIndex(guiSAVEBUFFER, guiHATCH, 0, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);

          RestoreExternBackgroundRect(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
        }
        HandlePlayerTeamMemberDeathAfterSkullAnimation(pSoldier);
      }
      RESETTIMECOUNTER(pSoldier.value.PanelAnimateCounter, 160);
    }
  }

  if (pSoldier.value.fDeadPanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
      BltVideoObjectFromIndex(FRAME_BUFFER, guiDEAD, pSoldier.value.ubDeadPanelFrame, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);

      // Blit hatch!
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiHATCH, 0, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);

      InvalidateRegion(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, pSoldier.value.sPanelFaceX + TM_FACE_WIDTH, pSoldier.value.sPanelFaceY + TM_FACE_HEIGHT);
    }
    //}
  }

  if (pSoldier.value.fOpenPanel) {
    if (TIMECOUNTERDONE(pSoldier.value.PanelAnimateCounter, 160)) {
      pSoldier.value.bOpenPanelFrame--;

      if (pSoldier.value.bOpenPanelFrame < 0) {
        pSoldier.value.fOpenPanel = FALSE;
        pSoldier.value.bOpenPanelFrame = 0;

        if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
          RestoreExternBackgroundRect(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
        }
      }
      RESETTIMECOUNTER(pSoldier.value.PanelAnimateCounter, 160);
    }
  }

  if (pSoldier.value.fOpenPanel) {
    // Render panel!
    // if(gbPixelDepth==16)
    //{
    if (!gFacesData[pSoldier.value.iFaceIndex].fDisabled) {
      RestoreExternBackgroundRect(pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, TM_FACE_WIDTH, TM_FACE_HEIGHT);
      BltVideoObjectFromIndex(FRAME_BUFFER, guiCLOSE, pSoldier.value.bOpenPanelFrame, pSoldier.value.sPanelFaceX, pSoldier.value.sPanelFaceY, VO_BLT_SRCTRANSPARENCY, NULL);
      // InvalidateRegion( sTEAMFacesXY[ ubOpenPanelID ], sTEAMFacesXY[ ubOpenPanelID + 1 ], sTEAMFacesXY[ ubOpenPanelID ] + TM_FACE_WIDTH, sTEAMFacesXY[ ubOpenPanelID + 1 ] + TM_FACE_HEIGHT );
    }
    //}
  }
}

function HandleSoldierFaceFlash(pSoldier: Pointer<SOLDIERTYPE>, sFaceX: INT16, sFaceY: INT16): void {
}

function RenderSoldierTeamInv(pSoldier: Pointer<SOLDIERTYPE>, sX: INT16, sY: INT16, ubPanelNum: UINT8, fDirty: BOOLEAN): void {
  if (pSoldier.value.bActive && !(pSoldier.value.uiStatusFlags & SOLDIER_DEAD)) {
    if (pSoldier.value.uiStatusFlags & SOLDIER_DRIVER) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiVEHINV, 0, sX, sY, VO_BLT_SRCTRANSPARENCY, NULL);
      RestoreExternBackgroundRect(sX, sY, (TM_INV_WIDTH), (TM_INV_HEIGHT));
    } else {
      // Look in primary hand
      INVRenderItem(guiSAVEBUFFER, pSoldier, addressof(pSoldier.value.inv[HANDPOS]), sX, sY, TM_INV_WIDTH, TM_INV_HEIGHT, fDirty, addressof(gfTEAM_HandInvDispText[ubPanelNum][HANDPOS]), 0, FALSE, 0);
    }

    if (pSoldier.value.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
      BltVideoObjectFromIndex(guiSAVEBUFFER, guiVEHINV, 1, sX, (sY + TM_INV_HAND_SEPY), VO_BLT_SRCTRANSPARENCY, NULL);
      RestoreExternBackgroundRect(sX, (sY + TM_INV_HAND_SEPY), (TM_INV_WIDTH), (TM_INV_HEIGHT));
    } else {
      // Do secondary hand
      INVRenderItem(guiSAVEBUFFER, pSoldier, addressof(pSoldier.value.inv[SECONDHANDPOS]), sX, (sY + TM_INV_HAND_SEPY), TM_INV_WIDTH, TM_INV_HEIGHT, fDirty, addressof(gfTEAM_HandInvDispText[ubPanelNum][SECONDHANDPOS]), 0, FALSE, 0);
    }
  }
}

function TMFirstHandInvCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  // If our flags are set to do this, gofoit!
  if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (!MercPtrs[ubSoldierID].value.bActive) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // OK FOR NOW, DROP ITEM WHERE BUDDY IS
    {
      //	SOLDIERTYPE *pSoldier;

      //	if(	GetSoldier( &pSoldier, ubSoldierID ) )
      //	{
      //	}
    }
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
  }
}

function TMClickFirstHandInvCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let usOldHandItem: UINT16;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY)
    return;

  if (iReason == MSYS_CALLBACK_REASON_LBUTTON_UP) {
    // Change to use cursor mode...
    guiPendingOverrideEvent = A_ON_TERRAIN;
  }

  if (iReason == MSYS_CALLBACK_REASON_RBUTTON_UP) {
    if (!AM_A_ROBOT(MercPtrs[ubSoldierID])) {
      usOldHandItem = MercPtrs[ubSoldierID].value.inv[HANDPOS].usItem;
      // SwapOutHandItem( MercPtrs[ ubSoldierID ] );
      SwapHandItems(MercPtrs[ubSoldierID]);
      ReLoadSoldierAnimationDueToHandItemChange(MercPtrs[ubSoldierID], usOldHandItem, MercPtrs[ubSoldierID].value.inv[HANDPOS].usItem);
      fInterfacePanelDirty = DIRTYLEVEL2;
    }
  }
}

function TMClickSecondHandInvCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let ubID: UINT8;
  let ubSoldierID: UINT8;
  let usOldHandItem: UINT16;

  ubID = MSYS_GetRegionUserData(pRegion, 0);

  if (ubID == NOBODY)
    return;

  // Now use soldier ID values
  ubSoldierID = gTeamPanel[ubID].ubID;

  if (ubSoldierID == NOBODY)
    return;

  if (iReason == MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (MercPtrs[ubSoldierID].value.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
      ExitVehicle(MercPtrs[ubSoldierID]);
    }
  }

  if (iReason == MSYS_CALLBACK_REASON_RBUTTON_UP) {
    if (MercPtrs[ubSoldierID].value.uiStatusFlags & (SOLDIER_PASSENGER | SOLDIER_DRIVER)) {
    } else {
      if (!AM_A_ROBOT(MercPtrs[ubSoldierID])) {
        usOldHandItem = MercPtrs[ubSoldierID].value.inv[HANDPOS].usItem;
        SwapHandItems(MercPtrs[ubSoldierID]);
        ReLoadSoldierAnimationDueToHandItemChange(MercPtrs[ubSoldierID], usOldHandItem, MercPtrs[ubSoldierID].value.inv[HANDPOS].usItem);
        fInterfacePanelDirty = DIRTYLEVEL2;
      }
    }
  }
}

function PlayerExistsInSlot(ubID: UINT8): BOOLEAN {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubID) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

function GetTeamSlotFromPlayerID(ubID: UINT8): INT8 {
  let cnt: INT8;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubID) {
        return cnt;
      }
    }
  }

  return -1;
}

function RemovePlayerFromTeamSlotGivenMercID(ubMercID: UINT8): BOOLEAN {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      if (gTeamPanel[cnt].ubID == ubMercID) {
        RemovePlayerFromInterfaceTeamSlot(cnt);
        return TRUE;
      }
    }
  }

  return FALSE;
}

function AddPlayerToInterfaceTeamSlot(ubID: UINT8): void {
  let cnt: INT32;

  // If we are a vehicle don't ever add.....
  if (MercPtrs[ubID].value.uiStatusFlags & SOLDIER_VEHICLE) {
    return;
  }

  if (!PlayerExistsInSlot(ubID)) {
    // Find a free slot
    for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
      if (!gTeamPanel[cnt].fOccupied) {
        gTeamPanel[cnt].fOccupied = TRUE;
        gTeamPanel[cnt].ubID = ubID;

        MSYS_SetRegionUserData(addressof(gTEAM_FirstHandInv[cnt]), 0, cnt);
        MSYS_SetRegionUserData(addressof(gTEAM_FaceRegions[cnt]), 0, cnt);

        // DIRTY INTERFACE
        fInterfacePanelDirty = DIRTYLEVEL2;

        // Set ID to do open anim
        MercPtrs[ubID].value.fUInewMerc = TRUE;

        break;
      }
    }
  }
}

function InitTEAMSlots(): BOOLEAN {
  let cnt: INT32;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    gTeamPanel[cnt].fOccupied = FALSE;
    gTeamPanel[cnt].ubID = NOBODY;
  }

  return TRUE;
}

function GetPlayerIDFromInterfaceTeamSlot(ubPanelSlot: UINT8, pubID: Pointer<UINT8>): BOOLEAN {
  if (ubPanelSlot >= NUM_TEAM_SLOTS) {
    return FALSE;
  }

  if (gTeamPanel[ubPanelSlot].fOccupied) {
    *pubID = gTeamPanel[ubPanelSlot].ubID;
    return TRUE;
  } else {
    return FALSE;
  }
}

function RemoveAllPlayersFromSlot(): void {
  let cnt: int;

  for (cnt = 0; cnt < NUM_TEAM_SLOTS; cnt++) {
    RemovePlayerFromInterfaceTeamSlot(cnt);
  }
}

function RemovePlayerFromInterfaceTeamSlot(ubPanelSlot: UINT8): BOOLEAN {
  if (ubPanelSlot >= NUM_TEAM_SLOTS) {
    return FALSE;
  }

  if (gTeamPanel[ubPanelSlot].fOccupied) {
    if (!(MercPtrs[gTeamPanel[ubPanelSlot].ubID].value.uiStatusFlags & SOLDIER_DEAD)) {
      // Set Id to close
      MercPtrs[gTeamPanel[ubPanelSlot].ubID].value.fUICloseMerc = TRUE;
    }

    // Set face to inactive...
    SetAutoFaceInActive(MercPtrs[gTeamPanel[ubPanelSlot].ubID].value.iFaceIndex);

    gTeamPanel[ubPanelSlot].fOccupied = FALSE;
    gTeamPanel[ubPanelSlot].ubID = NOBODY;

    MSYS_SetRegionUserData(addressof(gTEAM_FirstHandInv[ubPanelSlot]), 0, NOBODY);
    MSYS_SetRegionUserData(addressof(gTEAM_FaceRegions[ubPanelSlot]), 0, NOBODY);

    // DIRTY INTERFACE
    fInterfacePanelDirty = DIRTYLEVEL2;

    return TRUE;
  } else {
    return FALSE;
  }
}

function RenderTownIDString(): void {
  let zTownIDString: CHAR16[] /* [80] */;
  let sFontX: INT16;
  let sFontY: INT16;

  // Render town, position
  SetFont(COMPFONT);
  SetFontForeground(183);
  SetFontBackground(FONT_BLACK);

  GetSectorIDString(gWorldSectorX, gWorldSectorY, gbWorldSectorZ, zTownIDString, TRUE);
  ReduceStringLength(zTownIDString, 80, COMPFONT);
  VarFindFontCenterCoordinates(548, 425, 80, 16, COMPFONT, addressof(sFontX), addressof(sFontY), zTownIDString);
  mprintf(sFontX, sFontY, "%s", zTownIDString);
}

function CheckForAndAddMercToTeamPanel(pSoldier: Pointer<SOLDIERTYPE>): void {
  if (pSoldier.value.bActive) {
    // Add to interface if the are ours
    if (pSoldier.value.bTeam == gbPlayerNum) {
      // Are we in the loaded sector?
      if (pSoldier.value.sSectorX == gWorldSectorX && pSoldier.value.sSectorY == gWorldSectorY && pSoldier.value.bSectorZ == gbWorldSectorZ && !pSoldier.value.fBetweenSectors && pSoldier.value.bInSector) {
        // IF on duty....
        if ((pSoldier.value.bAssignment == CurrentSquad()) || (SoldierIsDeadAndWasOnSquad(pSoldier, (CurrentSquad())))) {
          if (pSoldier.value.bAssignment == ASSIGNMENT_DEAD) {
            pSoldier.value.fUICloseMerc = FALSE;
          }
          // ATE: ALrighty, if we have the insertion code of helicopter..... don't add just yet!
          /// ( will add in heli code )
          if (pSoldier.value.ubStrategicInsertionCode != INSERTION_CODE_CHOPPER) {
            AddPlayerToInterfaceTeamSlot(pSoldier.value.ubID);
          }

          // ARE WE A VEHICLE.....
          if (pSoldier.value.uiStatusFlags & SOLDIER_VEHICLE) {
            AddPassangersToTeamPanel(pSoldier.value.bVehicleID);
          }
        }
      } else {
        // Make sure we are NOT in this world!
        // Set gridno to one that's not visib;l
        RemoveSoldierFromGridNo(pSoldier);

        // Remove slot from tactical
        RemoveMercSlot(pSoldier);
      }
    }
  }
}

function FindNextMercInTeamPanel(pSoldier: Pointer<SOLDIERTYPE>, fGoodForLessOKLife: BOOLEAN, fOnlyRegularMercs: BOOLEAN): UINT8 {
  let cnt: INT32;
  let bFirstID: INT32;
  let pTeamSoldier: Pointer<SOLDIERTYPE>;

  bFirstID = GetTeamSlotFromPlayerID(pSoldier.value.ubID);

  if (bFirstID == -1) {
    return pSoldier.value.ubID;
  }

  for (cnt = (bFirstID + 1); cnt < NUM_TEAM_SLOTS; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      // Set Id to close
      pTeamSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      if (fOnlyRegularMercs) {
        if (pTeamSoldier.value.bActive && (AM_AN_EPC(pTeamSoldier) || AM_A_ROBOT(pTeamSoldier))) {
          continue;
        }
      }

      if (fGoodForLessOKLife) {
        if (pTeamSoldier.value.bLife > 0 && pTeamSoldier.value.bActive && pTeamSoldier.value.bInSector && pTeamSoldier.value.bTeam == gbPlayerNum && pTeamSoldier.value.bAssignment < ON_DUTY && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.value.bAssignment == pTeamSoldier.value.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      } else {
        if (OK_CONTROLLABLE_MERC(pTeamSoldier) && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.value.bAssignment == pTeamSoldier.value.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      }
    }
  }

  // none found,
  // Now loop back
  for (cnt = 0; cnt < bFirstID; cnt++) {
    if (gTeamPanel[cnt].fOccupied) {
      pTeamSoldier = MercPtrs[gTeamPanel[cnt].ubID];

      if (fOnlyRegularMercs) {
        if (pTeamSoldier.value.bActive && (AM_AN_EPC(pTeamSoldier) || AM_A_ROBOT(pTeamSoldier))) {
          continue;
        }
      }

      if (fGoodForLessOKLife) {
        if (pTeamSoldier.value.bLife > 0 && pTeamSoldier.value.bActive && pTeamSoldier.value.bInSector && pTeamSoldier.value.bTeam == gbPlayerNum && pTeamSoldier.value.bAssignment < ON_DUTY && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.value.bAssignment == pTeamSoldier.value.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      } else {
        if (OK_CONTROLLABLE_MERC(pTeamSoldier) && OK_INTERRUPT_MERC(pTeamSoldier) && pSoldier.value.bAssignment == pTeamSoldier.value.bAssignment) {
          return gTeamPanel[cnt].ubID;
        }
      }
    }
  }

  // IF we are here, keep as we always were!
  return pSoldier.value.ubID;
}

function HelpTextDoneCallback(): void {
  gfRerenderInterfaceFromHelpText = TRUE;

  // To redraw the Store Keeper Interface
  gubSkiDirtyLevel = SKI_DIRTY_LEVEL2;
}

function DisableTacticalTeamPanelButtons(fDisable: BOOLEAN): void {
  gfDisableTacticalPanelButtons = fDisable;
}

function BeginKeyPanelFromKeyShortcut(): void {
  let pSoldier: Pointer<SOLDIERTYPE> = NULL;
  let sStartYPosition: INT16 = 0;
  let sWidth: INT16 = 0;
  let sHeight: INT16 = 0;

  if (gsCurInterfacePanel != SM_PANEL) {
    return;
  }

  if (gpSMCurrentMerc == NULL) {
    return;
  }

  if (gfInKeyRingPopup) {
    return;
  }

  sStartYPosition = INV_INTERFACE_START_Y;
  sWidth = 640;
  sHeight = (480 - (INV_INTERFACE_START_Y));
  pSoldier = gpSMCurrentMerc;

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  InitKeyRingPopup(pSoldier, 0, sStartYPosition, sWidth, sHeight);
}

function KeyRingItemPanelButtonCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let pSoldier: Pointer<SOLDIERTYPE> = NULL;
  let sStartYPosition: INT16 = 0;
  let sWidth: INT16 = 0;
  let sHeight: INT16 = 0;

  if (guiCurrentScreen == MAP_SCREEN) {
    if (bSelectedInfoChar == -1) {
      return;
    }

    if (gCharactersList[bSelectedInfoChar].fValid == FALSE) {
      return;
    }

    pSoldier = addressof(Menptr[gCharactersList[bSelectedInfoChar].usSolID]);
    sStartYPosition = MAP_START_KEYRING_Y;
    sWidth = 261;
    sHeight = (359 - 107);
  } else {
    if (gpSMCurrentMerc == NULL) {
      return;
    }

    sStartYPosition = INV_INTERFACE_START_Y;
    sWidth = 640;
    sHeight = (480 - (INV_INTERFACE_START_Y));
    pSoldier = gpSMCurrentMerc;
  }

  // if we are in the shop keeper interface
  if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE)
    return;

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP) {
    if (guiCurrentScreen == MAP_SCREEN) {
      // want the inv done button shutdown and the region behind the keyring shaded
      // ForceButtonUnDirty( giMapInvDoneButton );
      // shade the background
      ShadowVideoSurfaceRect(FRAME_BUFFER, 0, 107, 261, 359);
      InvalidateRegion(0, 107, 261, 359);
    }

    InitKeyRingPopup(pSoldier, 0, sStartYPosition, sWidth, sHeight);
  }
}

function KeyRingSlotInvClickCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  let uiKeyRing: UINT32;
  // Copyies of values
  let usOldItemIndex: UINT16;
  /* static */ let fRightDown: BOOLEAN = FALSE;
  /* static */ let fLeftDown: BOOLEAN = FALSE;
  let iNumberOfKeysTaken: INT32 = 0;

  uiKeyRing = MSYS_GetRegionUserData(pRegion, 0);

  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  }

  // if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN )
  //{
  //	fLeftDown = TRUE;
  //}
  // else if (iReason & MSYS_CALLBACK_REASON_LBUTTON_UP && fLeftDown )
  if (iReason & MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    fLeftDown = FALSE;

    // if we are in the shop keeper interface
    if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
      let InvSlot: INVENTORY_IN_SLOT;

      if (gMoveingItem.sItemIndex == 0) {
        // Delete the contents of the item cursor
        memset(addressof(gMoveingItem), 0, sizeof(INVENTORY_IN_SLOT));
      } else {
        memset(addressof(InvSlot), 0, sizeof(INVENTORY_IN_SLOT));

        // Return if empty
        // if ( gpSMCurrentMerc->inv[ uiHandPos ].usItem == NOTHING )
        //	return;

        // Fill out the inv slot for the item
        // InvSlot.sItemIndex = gpSMCurrentMerc->inv[ uiHandPos ].usItem;
        //			InvSlot.ubNumberOfItems = gpSMCurrentMerc->inv[ uiHandPos ].ubNumberOfObjects;
        //			InvSlot.ubItemQuality = gpSMCurrentMerc->inv[ uiHandPos ].bGunStatus;
        // memcpy( &InvSlot.ItemObject, &gpSMCurrentMerc->inv[ uiHandPos ], sizeof( OBJECTTYPE ) );
        // InvSlot.ubLocationOfObject = PLAYERS_INVENTORY;

        // InvSlot.ubIdOfMercWhoOwnsTheItem = gpSMCurrentMerc->ubProfile;

        // Add the item to the Players Offer Area
        // AddItemToPlayersOfferArea( gpSMCurrentMerc->ubProfile, &InvSlot, (UINT8)uiHandPos );

        // Dirty
        fInterfacePanelDirty = DIRTYLEVEL2;
      }
      return;
    }

    // If we do not have an item in hand, start moving it
    if (gpItemPointer == NULL) {
      // Return if empty
      if ((gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER) || (gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubNumber == 0))
        return;

      // If our flags are set to do this, gofoit!
      if ((guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN)) {
      } else {
        if (gpItemPopupSoldier.value.ubID != gusSelectedSoldier) {
          SelectSoldier(gpItemPopupSoldier.value.ubID, FALSE, FALSE);
        }
      }

      usOldItemIndex = uiKeyRing;

      BeginKeyRingItemPointer(gpItemPopupSoldier, usOldItemIndex);
      // BeginItemPointer( gpSMCurrentMerc, (UINT8)uiHandPos );
    } else {
      let ubSrcID: UINT8;
      let ubDestID: UINT8;
      let fOKToGo: BOOLEAN = FALSE;
      let fDeductPoints: BOOLEAN = FALSE;

      if ((gpItemPointer.value.usItem < FIRST_KEY) || (gpItemPointer.value.usItem > KEY_32)) {
        return;
      }

      // ATE: OK, get source, dest guy if different... check for and then charge appropriate APs
      ubSrcID = gCharactersList[bSelectedInfoChar].usSolID;
      if (gpItemPointerSoldier) {
        ubDestID = gpItemPointerSoldier.value.ubID;
      } else {
        ubDestID = ubSrcID;
      }

      if (ubSrcID == ubDestID) {
        // We are doing this ourselve, continue
        fOKToGo = TRUE;
      } else {
        // These guys are different....
        fDeductPoints = TRUE;

        // First check points for src guy
        if (gpItemPointerSoldier.value.bLife >= CONSCIOUSNESS) {
          if (EnoughPoints(gpItemPointerSoldier, 2, 0, TRUE)) {
            fOKToGo = TRUE;
          }
        } else {
          fOKToGo = TRUE;
        }

        // Should we go on?
        if (fOKToGo) {
          if (gpSMCurrentMerc.value.bLife >= CONSCIOUSNESS) {
            if (EnoughPoints(gpSMCurrentMerc, 2, 0, TRUE)) {
              fOKToGo = TRUE;
            } else {
              fOKToGo = FALSE;
            }
          }
        }
      }

      if (fOKToGo) {
        // usOldItemIndex = gpSMCurrentMerc->inv[ uiHandPos ].usItem;
        // usNewItemIndex = gpItemPointer->usItem;

        if (gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER || gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubKeyID == gpItemPointer.value.ubKeyID) {
          // Try to place here
          if ((iNumberOfKeysTaken = AddKeysToSlot(gpItemPopupSoldier, uiKeyRing, gpItemPointer))) {
            if (fDeductPoints) {
              // Deduct points
              if (gpItemPointerSoldier.value.bLife >= CONSCIOUSNESS) {
                DeductPoints(gpItemPointerSoldier, 2, 0);
              }
              if (gpItemPopupSoldier.value.bLife >= CONSCIOUSNESS) {
                DeductPoints(gpItemPopupSoldier, 2, 0);
              }
            }

            // Dirty
            fInterfacePanelDirty = DIRTYLEVEL2;

            gpItemPointer.value.ubNumberOfObjects -= iNumberOfKeysTaken;

            // Check if it's the same now!
            if (gpItemPointer.value.ubNumberOfObjects == 0) {
              if (guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN) {
                MAPEndItemPointer();
              } else {
                EndItemPointer();
              }
            }

            // Setup a timer....
            // guiMouseOverItemTime = GetJA2Clock( );
            // gfCheckForMouseOverItem = TRUE;
            // gbCheckForMouseOverItemPos = (INT8)uiHandPos;
          }
        } else {
          // Swap!
          SwapKeysToSlot(gpItemPopupSoldier, uiKeyRing, gpItemPointer);

          if (fDeductPoints) {
            // Deduct points
            if (gpItemPointerSoldier && gpItemPointerSoldier.value.bLife >= CONSCIOUSNESS) {
              DeductPoints(gpItemPointerSoldier, 2, 0);
            }
            if (gpSMCurrentMerc.value.bLife >= CONSCIOUSNESS) {
              DeductPoints(gpSMCurrentMerc, 2, 0);
            }
          }

          // Dirty
          fInterfacePanelDirty = DIRTYLEVEL2;
        }
      }
    }

    UpdateItemHatches();
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_DWN) {
    fRightDown = TRUE;
  } else if (iReason & MSYS_CALLBACK_REASON_RBUTTON_UP && fRightDown) {
    fRightDown = FALSE;

    // Return if empty
    if ((gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubKeyID == INVALID_KEY_NUMBER) || (gpItemPopupSoldier.value.pKeyRing[uiKeyRing].ubNumber == 0)) {
      DeleteKeyRingPopup();
      fTeamPanelDirty = TRUE;
      return;
    }
    // Some global stuff here - for esc, etc
    // Check for # of slots in item
    if (!InItemDescriptionBox()) {
      if (guiTacticalInterfaceFlags & INTERFACE_MAPSCREEN) {
        // InitKeyItemDescriptionBox( gpItemPopupSoldier, (UINT8)uiKeyRing, MAP_ITEMDESC_START_X, MAP_ITEMDESC_START_Y, 0 );
      } else {
        InitKeyItemDescriptionBox(gpItemPopupSoldier, uiKeyRing, SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0);
      }
    }
  } else if (iReason & MSYS_CALLBACK_REASON_LOST_MOUSE) {
    fRightDown = FALSE;
    fLeftDown = FALSE;
  }
}

function DisableSMPpanelButtonsWhenInShopKeeperInterface(fDontDrawButtons: BOOLEAN): void {
  // Go through the buttons that will be under the ShopKeepers ATM panel and disable them
  DisableButton(iSMPanelButtons[STANCEUP_BUTTON]);
  DisableButton(iSMPanelButtons[UPDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[CLIMB_BUTTON]);
  DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);
  DisableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
  DisableButton(iSMPanelButtons[LOOK_BUTTON]);
  DisableButton(iSMPanelButtons[TALK_BUTTON]);
  DisableButton(iSMPanelButtons[MUTE_BUTTON]);

  DisableButton(giSMStealthButton);

  // Make sure the options button is disabled
  DisableButton(iSMPanelButtons[OPTIONS_BUTTON]);

  // Make sure the mapscreen button is disabled
  DisableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);

  DisableButton(iSMPanelButtons[STANCEUP_BUTTON]);
  DisableButton(iSMPanelButtons[UPDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[CLIMB_BUTTON]);
  DisableButton(iSMPanelButtons[STANCEDOWN_BUTTON]);
  DisableButton(iSMPanelButtons[HANDCURSOR_BUTTON]);
  DisableButton(iSMPanelButtons[BURSTMODE_BUTTON]);
  DisableButton(iSMPanelButtons[LOOK_BUTTON]);
  DisableButton(iSMPanelButtons[TALK_BUTTON]);
  DisableButton(iSMPanelButtons[MUTE_BUTTON]);

  DisableButton(giSMStealthButton);

  if (fDontDrawButtons) {
    // ATM:

    // Go through the buttons that will be under the ShopKeepers ATM panel and disable them
    ButtonList[iSMPanelButtons[STANCEUP_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[CLIMB_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[STANCEDOWN_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[BURSTMODE_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[TALK_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;
    ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.uiFlags &= ~BUTTON_DIRTY;

    ButtonList[giSMStealthButton].value.uiFlags &= ~BUTTON_DIRTY;

    // Make sure the options button is disabled
    ButtonList[iSMPanelButtons[OPTIONS_BUTTON]].value.uiFlags &= ~BUTTON_ENABLED;

    // Make sure the mapscreen button is disabled
    ButtonList[iSMPanelButtons[SM_MAP_SCREEN_BUTTON]].value.uiFlags &= ~BUTTON_ENABLED;

    ButtonList[iSMPanelButtons[STANCEUP_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[UPDOWN_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[CLIMB_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[STANCEDOWN_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[HANDCURSOR_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[BURSTMODE_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[LOOK_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[TALK_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
    ButtonList[iSMPanelButtons[MUTE_BUTTON]].value.uiFlags |= BUTTON_FORCE_UNDIRTY;

    ButtonList[giSMStealthButton].value.uiFlags |= BUTTON_FORCE_UNDIRTY;
  }
}

function IsMouseInRegion(pRegion: Pointer<MOUSE_REGION>): BOOLEAN {
  if ((gusMouseXPos >= pRegion.value.RegionTopLeftX) && (gusMouseXPos <= pRegion.value.RegionBottomRightX) && (gusMouseYPos >= pRegion.value.RegionTopLeftY) && (gusMouseYPos <= pRegion.value.RegionBottomRightY)) {
    return TRUE;
  } else {
    return FALSE;
  }
}

function EnableButtonsForInItemBox(fEnable: BOOLEAN): void {
  if (!fEnable) {
    DisableButton(iSMPanelButtons[NEXTMERC_BUTTON]);
    DisableButton(iSMPanelButtons[PREVMERC_BUTTON]);
    DisableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
  } else {
    EnableButton(iSMPanelButtons[NEXTMERC_BUTTON]);
    EnableButton(iSMPanelButtons[PREVMERC_BUTTON]);

    if (!gfDisableTacticalPanelButtons) {
      EnableButton(iSMPanelButtons[SM_MAP_SCREEN_BUTTON]);
    }
  }
}

function SMInvMoneyButtonCallback(pRegion: Pointer<MOUSE_REGION>, iReason: INT32): void {
  if (iReason & MSYS_CALLBACK_REASON_INIT) {
    return;
  } else if (iReason == MSYS_CALLBACK_REASON_LBUTTON_DWN) {
    // If the current merc is to far away, dont allow anything to be done
    if (gfSMDisableForItems)
      return;

    // if the player has an item in his hand,
    if (gpItemPointer != NULL) {
      // and the item is money
      if (Item[gpItemPointer.value.usItem].usItemClass == IC_MONEY) {
        let zText: CHAR16[] /* [512] */;
        let zMoney: CHAR16[] /* [64] */;

        // Make sure we go back to movement mode...
        guiPendingOverrideEvent = A_CHANGE_TO_MOVE;
        HandleTacticalUI();

        swprintf(zMoney, "%d", gpItemPointer.value.uiMoneyAmount);

        InsertCommasForDollarFigure(zMoney);
        InsertDollarSignInToString(zMoney);

        // ask the user if they are sure they want to deposit the money
        swprintf(zText, gzMoneyWithdrawMessageText[CONFIRMATION_TO_DEPOSIT_MONEY_TO_ACCOUNT], zMoney);

        if (guiCurrentScreen == SHOPKEEPER_SCREEN) {
          // if we are in the shop keeper interface, free the cursor
          if (guiTacticalInterfaceFlags & INTERFACE_SHOPKEEP_INTERFACE) {
            FreeMouseCursor();
          }

          DoMessageBox(MSG_BOX_BASIC_STYLE, zText, SHOPKEEPER_SCREEN, MSG_BOX_FLAG_YESNO, ConfirmationToDepositMoneyToPlayersAccount, NULL);
        } else
          DoMessageBox(MSG_BOX_BASIC_STYLE, zText, GAME_SCREEN, MSG_BOX_FLAG_YESNO, ConfirmationToDepositMoneyToPlayersAccount, NULL);
      }
    }

    // else bring up the money item description box to remove money from the players account
    else {
      // set the flag indicating we are removing money from the players account
      gfAddingMoneyToMercFromPlayersAccount = TRUE;

      // create the temp object from the players account balance
      //			if( LaptopSaveInfo.iCurrentBalance > MAX_MONEY_PER_SLOT )
      //				CreateMoney( MAX_MONEY_PER_SLOT, &gItemPointer );
      //			else
      CreateMoney(LaptopSaveInfo.iCurrentBalance, addressof(gItemPointer));

      InternalInitItemDescriptionBox(addressof(gItemPointer), SM_ITEMDESC_START_X, SM_ITEMDESC_START_Y, 0, gpSMCurrentMerc);
    }
  }
}

function ConfirmationToDepositMoneyToPlayersAccount(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    // add the money to the players account
    AddTransactionToPlayersBook(MERC_DEPOSITED_MONEY_TO_PLAYER_ACCOUNT, gpSMCurrentMerc.value.ubProfile, GetWorldTotalMin(), gpItemPointer.value.uiMoneyAmount);

    // dirty shopkeeper
    gubSkiDirtyLevel = SKI_DIRTY_LEVEL2;

    EndItemPointer();
  }
}

function ReEvaluateDisabledINVPanelButtons(): void {
  gfReEvaluateDisabledINVPanelButtons = TRUE;
}

function CheckForReEvaluateDisabledINVPanelButtons(): void {
  // OK, if we currently have an item pointer up....
  if (gfReEvaluateDisabledINVPanelButtons) {
    if (gpItemPointer || gfInItemPickupMenu) {
      EnableSMPanelButtons(FALSE, TRUE);
    } else {
      EnableSMPanelButtons(TRUE, TRUE);
    }

    gfReEvaluateDisabledINVPanelButtons = FALSE;
  }
}

function AbandonBoxingCallback(ubExitValue: UINT8): void {
  if (ubExitValue == MSG_BOX_RETURN_YES) {
    // ok, proceed!
    SetBoxingState(NOT_BOXING);
    gfEnteringMapScreen = TRUE;
  }
  // otherwise do nothing
}

function GoToMapScreenFromTactical(): void {
  if (gTacticalStatus.bBoxingState != NOT_BOXING) {
    // pop up dialogue asking whether the player wants to abandon the fight
    DoMessageBox(MSG_BOX_BASIC_STYLE, Message[STR_ABANDON_FIGHT], GAME_SCREEN, MSG_BOX_FLAG_YESNO, AbandonBoxingCallback, NULL);
    return;
  }
  // ok, proceed!
  gfEnteringMapScreen = TRUE;
}

function HandleTacticalEffectsOfEquipmentChange(pSoldier: Pointer<SOLDIERTYPE>, uiInvPos: UINT32, usOldItem: UINT16, usNewItem: UINT16): void {
  // if in attached weapon mode and don't have weapon with GL attached in hand, reset weapon mode
  if (pSoldier.value.bWeaponMode == WM_ATTACHED && FindAttachment(addressof(pSoldier.value.inv[HANDPOS]), UNDER_GLAUNCHER) == NO_SLOT) {
    pSoldier.value.bWeaponMode = WM_NORMAL;
    pSoldier.value.bDoBurst = FALSE;
  }

  // if he is loaded tactically
  if (pSoldier.value.bInSector) {
    // If this is our main hand
    if (uiInvPos == HANDPOS || uiInvPos == SECONDHANDPOS) {
      // check if we need to change animation!
      ReLoadSoldierAnimationDueToHandItemChange(pSoldier, usOldItem, usNewItem);
    }

    // if this is head gear
    if (uiInvPos == HEAD1POS || uiInvPos == HEAD2POS) {
      // Could be because of GOGGLES change...  Re-create light...
      DeleteSoldierLight(pSoldier);
      PositionSoldierLight(pSoldier);
    }
  } else {
    // as a minimum
    if ((Item[pSoldier.value.inv[HANDPOS].usItem].usItemClass & IC_WEAPON) && Weapon[pSoldier.value.inv[HANDPOS].usItem].ubShotsPerBurst == 0) {
      pSoldier.value.bDoBurst = FALSE;
      pSoldier.value.bWeaponMode = WM_NORMAL;
    }
  }
}
